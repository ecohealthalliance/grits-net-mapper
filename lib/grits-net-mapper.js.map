{"version":3,"sources":["webpack:///grits-net-mapper.js","webpack:///webpack/bootstrap 86b4544da83639d210cc","webpack:///./src/grits-net-mapper.coffee","webpack:///./~/leaflet-polylinedecorator/leaflet.polylineDecorator.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","L","MapPath","Path","extend","map","smoothFactor","pointList","pathLine","pathLineDecorator","origin","destination","destWAC","miles","origWAC","totalSeats","seats_week","stops","flights","visible","onAdd","this","show","addTo","departureAirport","marker","arrivalAirport","hide","removeLayer","update","flight","MapNode","Miles","setPopup","initialize","Stops","latlng","MapPaths","addInitializedPath","drawPath","midPoint","points","ud","latDif","Math","abs","lat","lng","calculateArch","curved","line","geometry","coordinates","turf","bezier","push","refresh","div","popup","DomUtil","create","Blaze","renderWithData","Template","pathDetails","setContent","bindPopup","setStyle","color","weight","archPos","i","len","mapPath","ref","mapPaths","length","equals","archPosition","Polyline","opacity","polylineDecorator","patterns","offset","repeat","symbol","Symbol","ArrowHead","pixelSize","pathOptions","factors","getLayerGroup","layerGroup","getFactorById","factor","_id","getMapPathByFactor","tempMapPath","addFactor","existingFactor","path","removeFactor","d1","d2","o1","o2","removeDest","removeOrig","splice","indexOf","updatePath","results","showPath","hidePath","hideAllPaths","showAllPaths","hideAllNodes","node","MapNodes","mapNodes","showAllNodes","hideBetween","mapNodeA","mapNodeB","city","state","stateName","country","countryName","globalRegion","WAC","notes","code","name","key","onRemove","nodeDetails","LatLng","loc","contains","on","e","nodeEvent","getNodeByMarker","target","_leaflet_id","addInitializedNode","otherNode","selectedNode","markerId","j","len1","ref1","nodeClickEvent","alert","addNode","mapNode","exists","tempMapNode","removeNode","updateNode","mapNodesContains","mapNodeCount","hideNode","showNode","LineUtil","PolylineDecorator","computeAngle","a","b","atan2","y","x","PI","getPointPathPixelLength","pts","nbPts","pt","dist","prevPt","distanceTo","getPixelLength","pl","ll","getLatLngs","project","projectPatternOnPath","offsetRatio","endOffsetRatio","repeatRatio","pathAsPoints","l","pattern","projectPatternOnPointPath","latLng","unproject","positions","repeatIntervalLength","previous","interpolateOnPointPath","endOffsetPixels","remainingPath","slice","predecessor","remainingLength","ratio","nbVertices","heading","interpolateBetweenPoints","pathLength","ratioA","ratioB","distB","segmentRatio","ptA","ptB","Point","LayerGroup","options","paths","prototype","Util","setOptions","_map","_initPaths","_initPatterns","_paths","_initPath","Polygon","isArray","_isCoordArray","isPolygon","latLngs","_isZoomDependant","_patterns","_parsePatternDef","isOffsetInPixels","isEndOffsetInPixels","isRepeatInPixels","symbolFactory","isZoomDependant","setPatterns","_softRedraw","setPaths","redraw","patternDef","cache","parseFloat","endOffset","_draw","off","_buildSymbols","directionPoints","symbols","buildSymbol","_getCache","zoom","pathIndex","zoomCache","_getDirectionPoints","getZoom","dirPoints","pathPixelLength","_redraw","clearCache","clearLayers","_drawPattern","addLayer","RotatedMarker","Marker","angle","_setPos","pos","TRANSFORM","_icon","style","Browser","ie","rad","costheta","cos","sintheta","sin","filter","setAngle","ang","rotatedMarker","Dash","Class","clickable","dirPoint","index","total","opts","d2r","add","subtract","dash","polygon","headAngle","stroke","_buildArrowPath","tipPoint","direction","radianArrowAngle","headAngle1","headAngle2","arrowHead1","arrowHead2","arrowHead","markerOptions","rotate","draggable","directionPoint"],"mappings":"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","file":"grits-net-mapper.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(2);\n\t\n\tL.MapPath = L.Path.extend({\n\t  id: null,\n\t  map: null,\n\t  smoothFactor: 1.0,\n\t  pointList: null,\n\t  pathLine: null,\n\t  pathLineDecorator: null,\n\t  origin: null,\n\t  destination: null,\n\t  destWAC: null,\n\t  miles: null,\n\t  origWAC: null,\n\t  totalSeats: null,\n\t  seats_week: null,\n\t  stops: null,\n\t  flights: 0,\n\t  visible: false,\n\t  onAdd: function(map) {\n\t    this.show();\n\t  },\n\t  show: function() {\n\t    this.visible = true;\n\t    if (this.pathLine !== null) {\n\t      this.pathLine.addTo(this.map);\n\t    }\n\t    if (this.pathLineDecorator !== null) {\n\t      this.pathLineDecorator.addTo(this.map);\n\t    }\n\t    if (this.departureAirport !== null && this.departureAirport.visible === false) {\n\t      this.departureAirport.marker.addTo(this.map);\n\t    }\n\t    if (this.arrivalAirport !== null && this.arrivalAirport.visible === false) {\n\t      this.arrivalAirport.marker.addTo(this.map);\n\t    }\n\t  },\n\t  hide: function() {\n\t    this.visible = false;\n\t    if (this.pathLine !== null) {\n\t      this.map.removeLayer(this.pathLine);\n\t    }\n\t    if (this.pathLineDecorator !== null) {\n\t      this.map.removeLayer(this.pathLineDecorator);\n\t    }\n\t  },\n\t  update: function(flight) {\n\t    if (flight.departureAirport !== null) {\n\t      this.departureAirport = new L.MapNode(flight.departureAirport, this.map);\n\t    }\n\t    if (flight.arrivalAirport !== null) {\n\t      this.arrivalAirport = new L.MapNode(flight.arrivalAirport, this.map);\n\t    }\n\t    if (flight.Miles !== null) {\n\t      this.miles = flight.Miles;\n\t    }\n\t    if (flight['Orig WAC']) {\n\t      this.origWAC = flight['Orig WAC'];\n\t    }\n\t    if (flight.totalSeats !== null) {\n\t      this.totalSeats = flight.totalSeats;\n\t    }\n\t    if (flight['Seats/Week'] !== null) {\n\t      this.seats_week = flight['Seats/Week'];\n\t    }\n\t    this.setPopup();\n\t  },\n\t  initialize: function(flight, map) {\n\t    this.map = map;\n\t    this.visible = true;\n\t    this.id = flight['_id'];\n\t    if (flight.departureAirport !== null) {\n\t      this.departureAirport = new L.MapNode(flight.departureAirport, this.map);\n\t    }\n\t    if (flight.arrivalAirport !== null) {\n\t      this.arrivalAirport = new L.MapNode(flight.arrivalAirport, this.map);\n\t    }\n\t    this.miles = flight.Miles;\n\t    this.origWAC = flight['Orig WAC'];\n\t    this.totalSeats = flight.totalSeats;\n\t    this.seats_week = flight['Seats/Week'];\n\t    this.stops = flight.Stops;\n\t    this.pointList = [this.departureAirport.latlng, this.arrivalAirport.latlng];\n\t    L.MapPaths.addInitializedPath(this);\n\t    return this.drawPath();\n\t  },\n\t  midPoint: function(points, ud) {\n\t    var latDif, midPoint;\n\t    latDif = void 0;\n\t    midPoint = void 0;\n\t    midPoint = [];\n\t    latDif = Math.abs(points[0].lat - points[1].lat);\n\t    if (points[0].lat > points[1].lat) {\n\t      if (ud) {\n\t        midPoint[0] = points[1].lat + latDif / 4;\n\t      } else {\n\t        midPoint[0] = points[0].lat - (latDif / 4);\n\t      }\n\t    } else {\n\t      if (ud) {\n\t        midPoint[0] = points[1].lat + latDif / 4;\n\t      } else {\n\t        midPoint[0] = points[1].lat - (latDif / 4);\n\t      }\n\t    }\n\t    midPoint[1] = (points[0].lng + points[1].lng) / 2;\n\t    return midPoint;\n\t  },\n\t  calculateArch: function() {\n\t    var curved, line;\n\t    curved = void 0;\n\t    line = void 0;\n\t    line = {\n\t      'geometry': {\n\t        'coordinates': [[this.departureAirport.latlng.lat, this.departureAirport.latlng.lng], this.midPoint([this.departureAirport.latlng, this.arrivalAirport.latlng], true), [this.arrivalAirport.latlng.lat, this.arrivalAirport.latlng.lng]]\n\t      }\n\t    };\n\t    curved = turf.bezier(line, 10000, 1);\n\t    this.pointList = curved.geometry.coordinates;\n\t    return this.pointList.push(this.arrivalAirport.latlng);\n\t  },\n\t  refresh: function() {\n\t    this.setPopup();\n\t    this.hide();\n\t    this.drawPath();\n\t    return this.show();\n\t  },\n\t  setPopup: function() {\n\t    var div, popup;\n\t    div = void 0;\n\t    popup = void 0;\n\t    popup = new L.popup;\n\t    div = L.DomUtil.create('div', '');\n\t    Blaze.renderWithData(Template.pathDetails, this, div);\n\t    popup.setContent(div);\n\t    return this.pathLine.bindPopup(popup);\n\t  },\n\t  setStyle: function(color, weight) {\n\t    this.color = color;\n\t    return this.weight = weight;\n\t  },\n\t  drawPath: function() {\n\t    var archPos, i, len, mapPath, ref;\n\t    archPos = void 0;\n\t    i = void 0;\n\t    len = void 0;\n\t    mapPath = void 0;\n\t    ref = void 0;\n\t    this.visible = true;\n\t    archPos = [];\n\t    ref = L.MapPaths.mapPaths;\n\t    i = 0;\n\t    len = ref.length;\n\t    while (i < len) {\n\t      mapPath = ref[i];\n\t      if (mapPath !== this) {\n\t        if (mapPath.departureAirport.equals(this.departureAirport) && mapPath.arrivalAirport.equals(this.arrivalAirport)) {\n\t          archPos[mapPath.archPosition] = true;\n\t        }\n\t      }\n\t      i++;\n\t    }\n\t    this.calculateArch(archPos);\n\t    this.pathLine = new L.Polyline(this.pointList, {\n\t      color: this.color,\n\t      weight: this.weight,\n\t      opacity: 0.8,\n\t      smoothFactor: 1\n\t    });\n\t    this.pathLineDecorator = L.polylineDecorator(this.pathLine, {\n\t      patterns: [\n\t        {\n\t          offset: '50px',\n\t          repeat: '100px',\n\t          symbol: new L.Symbol.ArrowHead({\n\t            pixelSize: 20,\n\t            pathOptions: {\n\t              color: this.color\n\t            }\n\t          })\n\t        }\n\t      ]\n\t    });\n\t    return this.setPopup();\n\t  }\n\t});\n\t\n\tL.mapPath = function(flight, map) {\n\t  return new L.MapPath(flight, map);\n\t};\n\t\n\tL.MapPaths = {\n\t  mapPaths: [],\n\t  factors: [],\n\t  getLayerGroup: function() {\n\t    return L.layerGroup(this.mapPaths);\n\t  },\n\t  getFactorById: function(id) {\n\t    var factor, i, len, ref;\n\t    factor = void 0;\n\t    i = void 0;\n\t    len = void 0;\n\t    ref = void 0;\n\t    ref = this.factors;\n\t    i = 0;\n\t    len = ref.length;\n\t    while (i < len) {\n\t      factor = ref[i];\n\t      if (factor._id === id) {\n\t        return factor;\n\t      }\n\t      i++;\n\t    }\n\t    return false;\n\t  },\n\t  getMapPathByFactor: function(factor) {\n\t    var i, len, ref, tempMapPath;\n\t    i = void 0;\n\t    len = void 0;\n\t    ref = void 0;\n\t    tempMapPath = void 0;\n\t    ref = this.mapPaths;\n\t    i = 0;\n\t    len = ref.length;\n\t    while (i < len) {\n\t      tempMapPath = ref[i];\n\t      if (tempMapPath.departureAirport.id === factor['departureAirport']._id && tempMapPath.arrivalAirport.id === factor['arrivalAirport']._id) {\n\t        return tempMapPath;\n\t      }\n\t      i++;\n\t    }\n\t    return false;\n\t  },\n\t  addInitializedPath: function(mapPath) {\n\t    return this.mapPaths.push(mapPath);\n\t  },\n\t  addFactor: function(id, factor, map) {\n\t    var existingFactor, path;\n\t    existingFactor = void 0;\n\t    path = void 0;\n\t    existingFactor = this.getFactorById(id);\n\t    if (existingFactor !== false) {\n\t      return this.getMapPathByFactor(existingFactor);\n\t    }\n\t    factor._id = id;\n\t    path = this.getMapPathByFactor(factor);\n\t    if (path !== false) {\n\t      path.totalSeats += factor['totalSeats'];\n\t    } else if (path === false) {\n\t      path = new L.MapPath(factor, map).addTo(map);\n\t      path.totalSeats = factor['totalSeats'];\n\t    }\n\t    this.factors.push(factor);\n\t    path.flights++;\n\t    path.refresh();\n\t    return path;\n\t  },\n\t  removeFactor: function(id) {\n\t    var d1, d2, factor, i, len, o1, o2, path, ref, removeDest, removeOrig, tempMapPath;\n\t    d1 = void 0;\n\t    d2 = void 0;\n\t    factor = void 0;\n\t    i = void 0;\n\t    len = void 0;\n\t    o1 = void 0;\n\t    o2 = void 0;\n\t    path = void 0;\n\t    ref = void 0;\n\t    removeDest = void 0;\n\t    removeOrig = void 0;\n\t    tempMapPath = void 0;\n\t    factor = this.getFactorById(id);\n\t    if (factor === false) {\n\t      return false;\n\t    }\n\t    this.factors.splice(this.factors.indexOf(factor), 1);\n\t    path = this.getMapPathByFactor(factor);\n\t    path.totalSeats -= factor['totalSeats'];\n\t    path.flights--;\n\t    if (path.flights === 0) {\n\t      path.arrivalAirport.hide();\n\t      path.departureAirport.hide();\n\t      path.hide();\n\t      return false;\n\t    } else {\n\t      path.show();\n\t      return {\n\t        'path': path,\n\t        'factor': factor\n\t      };\n\t    }\n\t  },\n\t  updatePath: function(id, mapPath, map) {\n\t    var i, len, ref, results, tempMapPath;\n\t    i = void 0;\n\t    len = void 0;\n\t    ref = void 0;\n\t    results = void 0;\n\t    tempMapPath = void 0;\n\t    ref = this.mapPaths;\n\t    results = [];\n\t    i = 0;\n\t    len = ref.length;\n\t    while (i < len) {\n\t      tempMapPath = ref[i];\n\t      if (tempMapPath.id === id) {\n\t        tempMapPath.hide();\n\t        tempMapPath.update(mapPath);\n\t        results.push(tempMapPath.show());\n\t      } else {\n\t        results.push(void 0);\n\t      }\n\t      i++;\n\t    }\n\t    return results;\n\t  },\n\t  showPath: function(mapPath) {\n\t    return mapPath.show();\n\t  },\n\t  hidePath: function(mapPath) {\n\t    return mapPath.hide();\n\t  },\n\t  hideAllPaths: function() {\n\t    var i, len, path, ref, results;\n\t    i = void 0;\n\t    len = void 0;\n\t    path = void 0;\n\t    ref = void 0;\n\t    results = void 0;\n\t    ref = this.mapPaths;\n\t    results = [];\n\t    i = 0;\n\t    len = ref.length;\n\t    while (i < len) {\n\t      path = ref[i];\n\t      results.push(path.hide());\n\t      i++;\n\t    }\n\t    return results;\n\t  },\n\t  showAllPaths: function() {\n\t    var i, len, path, ref, results;\n\t    i = void 0;\n\t    len = void 0;\n\t    path = void 0;\n\t    ref = void 0;\n\t    results = void 0;\n\t    ref = this.mapPaths;\n\t    results = [];\n\t    i = 0;\n\t    len = ref.length;\n\t    while (i < len) {\n\t      path = ref[i];\n\t      results.push(path.show());\n\t      i++;\n\t    }\n\t    return results;\n\t  },\n\t  hideAllNodes: function() {\n\t    var i, len, node, ref, results;\n\t    i = void 0;\n\t    len = void 0;\n\t    node = void 0;\n\t    ref = void 0;\n\t    results = void 0;\n\t    ref = L.MapNodes.mapNodes;\n\t    results = [];\n\t    i = 0;\n\t    len = ref.length;\n\t    while (i < len) {\n\t      node = ref[i];\n\t      results.push(node.hide());\n\t      i++;\n\t    }\n\t    return results;\n\t  },\n\t  showAllNodes: function() {\n\t    return L.MapNodes.showAllNodes();\n\t  },\n\t  hideBetween: function(mapNodeA, mapNodeB) {\n\t    var i, len, mapPath, ref, results;\n\t    i = void 0;\n\t    len = void 0;\n\t    mapPath = void 0;\n\t    ref = void 0;\n\t    results = void 0;\n\t    ref = this.mapPaths;\n\t    results = [];\n\t    i = 0;\n\t    len = ref.length;\n\t    while (i < len) {\n\t      mapPath = ref[i];\n\t      if (mapPath.departureAirport === mapNodeA && mapPath.arrivalAirport === mapNodeB) {\n\t        mapPath.hide();\n\t      }\n\t      if (mapPath.departureAirport === mapNodeB && mapPath.arrivalAirport === mapNodeA) {\n\t        results.push(mapPath.hide());\n\t      } else {\n\t        results.push(void 0);\n\t      }\n\t      i++;\n\t    }\n\t    return results;\n\t  }\n\t};\n\t\n\tL.MapNode = L.Path.extend({\n\t  visible: false,\n\t  latlng: null,\n\t  city: null,\n\t  state: null,\n\t  stateName: null,\n\t  country: null,\n\t  countryName: null,\n\t  globalRegion: null,\n\t  WAC: null,\n\t  notes: null,\n\t  code: null,\n\t  name: null,\n\t  key: null,\n\t  map: null,\n\t  marker: null,\n\t  onAdd: function(map) {\n\t    if (this.marker !== null) {\n\t      this.marker.addTo(map);\n\t    }\n\t  },\n\t  onRemove: function(map) {\n\t    map.removeLayer(this.marker);\n\t  },\n\t  setPopup: function() {\n\t    var div, popup;\n\t    div = void 0;\n\t    popup = void 0;\n\t    popup = new L.popup;\n\t    div = L.DomUtil.create('div', '');\n\t    Blaze.renderWithData(Template.nodeDetails, this, div);\n\t    popup.setContent(div);\n\t    return this.marker.bindPopup(popup);\n\t  },\n\t  initialize: function(node, map) {\n\t    var i, len, ref, results;\n\t    i = void 0;\n\t    len = void 0;\n\t    ref = void 0;\n\t    results = void 0;\n\t    this.map = map;\n\t    this.id = node['_id'];\n\t    this.name = node.name;\n\t    this.city = node.city;\n\t    this.state = node.state;\n\t    this.stateName = node.stateName;\n\t    this.country = node.country;\n\t    this.countryName = node.countryName;\n\t    this.globalRegion = node.globalRegion;\n\t    this.notes = node.notes;\n\t    this.WAC = node.WAC;\n\t    this.key = node.key;\n\t    this.latlng = new L.LatLng(node.loc.coordinates[1], node.loc.coordinates[0]);\n\t    if (!L.MapNodes.contains(this)) {\n\t      this.marker = L.marker(this.latlng);\n\t      this.marker.on('click', function(e) {\n\t        return Template.map.nodeEvent(L.MapNodes.getNodeByMarker(e.target._leaflet_id));\n\t      });\n\t      L.MapNodes.addInitializedNode(this);\n\t      return this.setPopup();\n\t    } else {\n\t      ref = L.MapNodes.mapNodes;\n\t      results = [];\n\t      i = 0;\n\t      len = ref.length;\n\t      while (i < len) {\n\t        node = ref[i];\n\t        if (node.id === this.id) {\n\t          results.push(this.marker = node.marker);\n\t        } else {\n\t          results.push(void 0);\n\t        }\n\t        i++;\n\t      }\n\t      return results;\n\t    }\n\t  },\n\t  equals: function(otherNode) {\n\t    return otherNode.latlng.lat === this.latlng.lat && otherNode.latlng.lng === this.latlng.lng;\n\t  },\n\t  hide: function() {\n\t    this.visible = false;\n\t    return this.map.removeLayer(this.marker);\n\t  },\n\t  show: function() {\n\t    this.visible = true;\n\t    this.marker = L.marker(this.latlng);\n\t    return this.setPopup();\n\t  }\n\t});\n\t\n\tL.MapNodes = {\n\t  selectedNode: null,\n\t  mapNodes: [],\n\t  getNodeByMarker: function(markerId) {\n\t    var j, len1, node, ref1;\n\t    ref1 = this.mapNodes;\n\t    for (j = 0, len1 = ref1.length; j < len1; j++) {\n\t      node = ref1[j];\n\t      if (node.marker._leaflet_id === markerId) {\n\t        return node;\n\t      }\n\t    }\n\t    return false;\n\t  },\n\t  getLayerGroup: function() {\n\t    return L.layerGroup(this.mapNodes);\n\t  },\n\t  addInitializedNode: function(node) {\n\t    return this.mapNodes.push(node);\n\t  },\n\t  nodeClickEvent: function(node) {\n\t    return alert(node.id);\n\t  },\n\t  addNode: function(mapNode) {\n\t    var exists, i, len, ref, tempMapNode;\n\t    exists = void 0;\n\t    i = void 0;\n\t    len = void 0;\n\t    ref = void 0;\n\t    tempMapNode = void 0;\n\t    exists = false;\n\t    ref = this.mapNodes;\n\t    i = 0;\n\t    len = ref.length;\n\t    while (i < len) {\n\t      tempMapNode = ref[i];\n\t      if (tempMapNode.key === mapNode['_id']) {\n\t        exists = true;\n\t      }\n\t      i++;\n\t    }\n\t    if (!exists) {\n\t      return new L.MapNode(mapNode, this.map);\n\t    }\n\t  },\n\t  removeNode: function(id) {\n\t    var i, len, ref, tempMapNode;\n\t    i = void 0;\n\t    len = void 0;\n\t    ref = void 0;\n\t    tempMapNode = void 0;\n\t    ref = this.mapNodes;\n\t    i = 0;\n\t    len = ref.length;\n\t    while (i < len) {\n\t      tempMapNode = ref[i];\n\t      if (tempMapNode.id === id) {\n\t        tempMapNode.hide();\n\t        this.mapNodes.splice(this.mapNodes.indexOf(tempMapNode), 1);\n\t        return;\n\t      }\n\t      i++;\n\t    }\n\t  },\n\t  updateNode: function(mapNode) {\n\t    var i, len, ref, results, tempMapNode;\n\t    i = void 0;\n\t    len = void 0;\n\t    ref = void 0;\n\t    results = void 0;\n\t    tempMapNode = void 0;\n\t    ref = this.mapNodes;\n\t    results = [];\n\t    i = 0;\n\t    len = ref.length;\n\t    while (i < len) {\n\t      tempMapNode = ref[i];\n\t      if (tempMapNode.id === tempMapNode['_id']) {\n\t        tempMapNode.hide();\n\t        tempMapNode.initialize(mapNode, this.map);\n\t        results.push(tempMapNode.show());\n\t      } else {\n\t        results.push(void 0);\n\t      }\n\t      i++;\n\t    }\n\t    return results;\n\t  },\n\t  contains: function(node) {\n\t    var i, len, mapNode, mapNodesContains, ref;\n\t    i = void 0;\n\t    len = void 0;\n\t    mapNode = void 0;\n\t    mapNodesContains = void 0;\n\t    ref = void 0;\n\t    mapNodesContains = false;\n\t    ref = this.mapNodes;\n\t    i = 0;\n\t    len = ref.length;\n\t    while (i < len) {\n\t      mapNode = ref[i];\n\t      if (mapNode.id === node.id) {\n\t        mapNodesContains = true;\n\t      }\n\t      i++;\n\t    }\n\t    return mapNodesContains;\n\t  },\n\t  mapNodeCount: function() {\n\t    return this.mapNodes.length;\n\t  },\n\t  hideNode: function(node) {\n\t    return node.hide();\n\t  },\n\t  showNode: function(node) {\n\t    return node.show();\n\t  },\n\t  hideAllNodes: function() {\n\t    var i, len, node, ref, results;\n\t    i = void 0;\n\t    len = void 0;\n\t    node = void 0;\n\t    ref = void 0;\n\t    results = void 0;\n\t    ref = this.mapNodes;\n\t    results = [];\n\t    i = 0;\n\t    len = ref.length;\n\t    while (i < len) {\n\t      node = ref[i];\n\t      results.push(node.hide());\n\t      i++;\n\t    }\n\t    return results;\n\t  },\n\t  showAllNodes: function() {\n\t    var i, len, node, ref, results;\n\t    i = void 0;\n\t    len = void 0;\n\t    node = void 0;\n\t    ref = void 0;\n\t    results = void 0;\n\t    ref = this.mapNodes;\n\t    results = [];\n\t    i = 0;\n\t    len = ref.length;\n\t    while (i < len) {\n\t      node = ref[i];\n\t      results.push(node.show());\n\t      i++;\n\t    }\n\t    return results;\n\t  }\n\t};\n\t\n\tL.mapNode = function(node, map) {\n\t  return new L.MapNode(node, map);\n\t};\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\r\n\tL.LineUtil.PolylineDecorator = {\r\n\t    computeAngle: function(a, b) {\r\n\t        return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI) + 90;\r\n\t    },\r\n\t\r\n\t    getPointPathPixelLength: function(pts) {\r\n\t        var nbPts = pts.length;\r\n\t        if(nbPts < 2) {\r\n\t            return 0;\r\n\t        }\r\n\t        var dist = 0,\r\n\t            prevPt = pts[0],\r\n\t            pt;\r\n\t        for(var i=1; i<nbPts; i++) {\r\n\t            dist += prevPt.distanceTo(pt = pts[i]);\r\n\t            prevPt = pt;\r\n\t        } \r\n\t        return dist;\r\n\t    },\r\n\t\r\n\t    getPixelLength: function(pl, map) {\r\n\t        var ll = (pl instanceof L.Polyline) ? pl.getLatLngs() : pl,\r\n\t            nbPts = ll.length;\r\n\t        if(nbPts < 2) {\r\n\t            return 0;\r\n\t        }\r\n\t        var dist = 0,\r\n\t            prevPt = map.project(ll[0]), pt; \r\n\t        for(var i=1; i<nbPts; i++) {\r\n\t            dist += prevPt.distanceTo(pt = map.project(ll[i]));\r\n\t            prevPt = pt;\r\n\t        } \r\n\t        return dist;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    * path: array of L.LatLng\r\n\t    * offsetRatio: the ratio of the total pixel length where the pattern will start\r\n\t    * endOffsetRatio: the ratio of the total pixel length where the pattern will end\r\n\t    * repeatRatio: the ratio of the total pixel length between two points of the pattern \r\n\t    * map: the map, to access the current projection state\r\n\t    */\r\n\t    projectPatternOnPath: function (path, offsetRatio, endOffsetRatio, repeatRatio, map) {\r\n\t        var pathAsPoints = [], i;\r\n\t\r\n\t        for(i=0, l=path.length; i<l; i++) {\r\n\t            pathAsPoints[i] = map.project(path[i]);\r\n\t        }\r\n\t        // project the pattern as pixel points\r\n\t        var pattern = this.projectPatternOnPointPath(pathAsPoints, offsetRatio, endOffsetRatio, repeatRatio);\r\n\t        // and convert it to latlngs;\r\n\t        for(i=0, l=pattern.length; i<l; i++) {\r\n\t            pattern[i].latLng = map.unproject(pattern[i].pt);\r\n\t        }        \r\n\t        return pattern;\r\n\t    },\r\n\t    \r\n\t    projectPatternOnPointPath: function (pts, offsetRatio, endOffsetRatio, repeatRatio) {\r\n\t        var positions = [];\r\n\t        // 1. compute the absolute interval length in pixels\r\n\t        var repeatIntervalLength = this.getPointPathPixelLength(pts) * repeatRatio;\r\n\t        // 2. find the starting point by using the offsetRatio and find the last pixel using endOffsetRatio\r\n\t        var previous = this.interpolateOnPointPath(pts, offsetRatio);\r\n\t        var endOffsetPixels = endOffsetRatio > 0 ? this.getPointPathPixelLength(pts) * endOffsetRatio : 0;\r\n\t        \r\n\t        positions.push(previous);\r\n\t        if(repeatRatio > 0) {\r\n\t            // 3. consider only the rest of the path, starting at the previous point\r\n\t            var remainingPath = pts;\r\n\t            remainingPath = remainingPath.slice(previous.predecessor);\r\n\t            \r\n\t            remainingPath[0] = previous.pt;\r\n\t            var remainingLength = this.getPointPathPixelLength(remainingPath);\r\n\t            \r\n\t            // 4. project as a ratio of the remaining length,\r\n\t            // and repeat while there is room for another point of the pattern\r\n\t\r\n\t            while(repeatIntervalLength <= remainingLength-endOffsetPixels) {\r\n\t                previous = this.interpolateOnPointPath(remainingPath, repeatIntervalLength/remainingLength);\r\n\t                positions.push(previous);\r\n\t                remainingPath = remainingPath.slice(previous.predecessor);\r\n\t                remainingPath[0] = previous.pt;\r\n\t                remainingLength = this.getPointPathPixelLength(remainingPath);\r\n\t            }\r\n\t        }\r\n\t        return positions;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    * pts: array of L.Point\r\n\t    * ratio: the ratio of the total length where the point should be computed\r\n\t    * Returns null if ll has less than 2 LatLng, or an object with the following properties:\r\n\t    *    latLng: the LatLng of the interpolated point\r\n\t    *    predecessor: the index of the previous vertex on the path\r\n\t    *    heading: the heading of the path at this point, in degrees\r\n\t    */\r\n\t    interpolateOnPointPath: function (pts, ratio) {\r\n\t        var nbVertices = pts.length;\r\n\t\r\n\t        if (nbVertices < 2) {\r\n\t            return null;\r\n\t        }\r\n\t        // easy limit cases: ratio negative/zero => first vertex\r\n\t        if (ratio <= 0) {\r\n\t            return {\r\n\t                pt: pts[0],\r\n\t                predecessor: 0,\r\n\t                heading: this.computeAngle(pts[0], pts[1])\r\n\t            };\r\n\t        }\r\n\t        // ratio >=1 => last vertex\r\n\t        if (ratio >= 1) {\r\n\t            return {\r\n\t                pt: pts[nbVertices - 1],\r\n\t                predecessor: nbVertices - 1,\r\n\t                heading: this.computeAngle(pts[nbVertices - 2], pts[nbVertices - 1])\r\n\t            };\r\n\t        }\r\n\t        // 1-segment-only path => direct linear interpolation\r\n\t        if (nbVertices == 2) {\r\n\t            return {\r\n\t                pt: this.interpolateBetweenPoints(pts[0], pts[1], ratio),\r\n\t                predecessor: 0,\r\n\t                heading: this.computeAngle(pts[0], pts[1])\r\n\t            };\r\n\t        }\r\n\t            \r\n\t        var pathLength = this.getPointPathPixelLength(pts);\r\n\t        var a = pts[0], b = a,\r\n\t            ratioA = 0, ratioB = 0,\r\n\t            distB = 0;\r\n\t        // follow the path segments until we find the one\r\n\t        // on which the point must lie => [ab] \r\n\t        var i = 1;\r\n\t        for (; i < nbVertices && ratioB < ratio; i++) {\r\n\t            a = b;\r\n\t            ratioA = ratioB;\r\n\t            b = pts[i];\r\n\t            distB += a.distanceTo(b);\r\n\t            ratioB = distB / pathLength;\r\n\t        }\r\n\t\r\n\t        // compute the ratio relative to the segment [ab]\r\n\t        var segmentRatio = (ratio - ratioA) / (ratioB - ratioA);\r\n\t\r\n\t        return {\r\n\t            pt: this.interpolateBetweenPoints(a, b, segmentRatio),\r\n\t            predecessor: i-2,\r\n\t            heading: this.computeAngle(a, b)\r\n\t        };\r\n\t    },\r\n\t    \r\n\t    /**\r\n\t    * Finds the point which lies on the segment defined by points A and B,\r\n\t    * at the given ratio of the distance from A to B, by linear interpolation. \r\n\t    */\r\n\t    interpolateBetweenPoints: function (ptA, ptB, ratio) {\r\n\t        if(ptB.x != ptA.x) {\r\n\t            return new L.Point(\r\n\t                (ptA.x * (1 - ratio)) + (ratio * ptB.x),\r\n\t                (ptA.y * (1 - ratio)) + (ratio * ptB.y)\r\n\t            );\r\n\t        }\r\n\t        // special case where points lie on the same vertical axis\r\n\t        return new L.Point(ptA.x, ptA.y + (ptB.y - ptA.y) * ratio);\r\n\t    }\r\n\t};\n\t\r\n\tL.PolylineDecorator = L.LayerGroup.extend({\r\n\t    options: {\r\n\t        patterns: []\r\n\t    },\r\n\t\r\n\t    initialize: function(paths, options) {\r\n\t        L.LayerGroup.prototype.initialize.call(this);\r\n\t        L.Util.setOptions(this, options);\r\n\t        this._map = null;\r\n\t        this._initPaths(paths);\r\n\t        this._initPatterns();\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    * Deals with all the different cases. p can be one of these types:\r\n\t    * array of LatLng, array of 2-number arrays, Polyline, Polygon,\r\n\t    * array of one of the previous.\r\n\t    */\r\n\t    _initPaths: function(p) {\r\n\t        this._paths = [];\r\n\t        var isPolygon = false;\r\n\t        if(p instanceof L.Polyline) {\r\n\t            this._initPath(p.getLatLngs(), (p instanceof L.Polygon));\r\n\t        } else if(L.Util.isArray(p) && p.length > 0) {\r\n\t            if(p[0] instanceof L.Polyline) {\r\n\t                for(var i=0; i<p.length; i++) {\r\n\t                    this._initPath(p[i].getLatLngs(), (p[i] instanceof L.Polygon));\r\n\t                }\r\n\t            } else {\r\n\t                this._initPath(p);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\t\r\n\t    _isCoordArray: function(ll) {\r\n\t        return(L.Util.isArray(ll) && ll.length > 0 && (\r\n\t            ll[0] instanceof L.LatLng ||\r\n\t            (L.Util.isArray(ll[0]) && ll[0].length == 2 && typeof ll[0][0] === 'number')\r\n\t        ));\r\n\t    },\r\n\t\r\n\t    _initPath: function(path, isPolygon) {\r\n\t        var latLngs;\r\n\t        // It may still be an array of array of coordinates\r\n\t        // (ex: polygon with rings)\r\n\t        if(this._isCoordArray(path)) {\r\n\t            latLngs = [path];\r\n\t        } else {\r\n\t            latLngs = path;\r\n\t        }\r\n\t        for(var i=0; i<latLngs.length; i++) {\r\n\t            // As of Leaflet >= v0.6, last polygon vertex (=first) isn't repeated.\r\n\t            // Our algorithm needs it, so we add it back explicitly.\r\n\t            if(isPolygon) {\r\n\t                latLngs[i].push(latLngs[i][0]);\r\n\t            }\r\n\t            this._paths.push(latLngs[i]);\r\n\t        }\r\n\t    },\r\n\t\r\n\t    _initPatterns: function() {\r\n\t        this._isZoomDependant = false;\r\n\t        this._patterns = [];\r\n\t        var pattern;\r\n\t        // parse pattern definitions and precompute some values\r\n\t        for(var i=0;i<this.options.patterns.length;i++) {\r\n\t            pattern = this._parsePatternDef(this.options.patterns[i]);\r\n\t            this._patterns.push(pattern);\r\n\t            // determines if we have to recompute the pattern on each zoom change\r\n\t            this._isZoomDependant = this._isZoomDependant ||\r\n\t                pattern.isOffsetInPixels ||\r\n\t                pattern.isEndOffsetInPixels ||\r\n\t                pattern.isRepeatInPixels ||\r\n\t                pattern.symbolFactory.isZoomDependant;\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    * Changes the patterns used by this decorator\r\n\t    * and redraws the new one.\r\n\t    */\r\n\t    setPatterns: function(patterns) {\r\n\t        this.options.patterns = patterns;\r\n\t        this._initPatterns();\r\n\t        this._softRedraw();\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    * Changes the patterns used by this decorator\r\n\t    * and redraws the new one.\r\n\t    */\r\n\t    setPaths: function(paths) {\r\n\t        this._initPaths(paths);\r\n\t        this.redraw();\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    * Parse the pattern definition\r\n\t    */\r\n\t    _parsePatternDef: function(patternDef, latLngs) {\r\n\t        var pattern = {\r\n\t            cache: [],\r\n\t            symbolFactory: patternDef.symbol,\r\n\t            isOffsetInPixels: false,\r\n\t            isEndOffsetInPixels: false,\r\n\t            isRepeatInPixels: false\r\n\t        };\r\n\t\r\n\t        // Parse offset and repeat values, managing the two cases:\r\n\t        // absolute (in pixels) or relative (in percentage of the polyline length)\r\n\t        if(typeof patternDef.offset === 'string' && patternDef.offset.indexOf('%') != -1) {\r\n\t            pattern.offset = parseFloat(patternDef.offset) / 100;\r\n\t        } else {\r\n\t            pattern.offset = patternDef.offset ? parseFloat(patternDef.offset) : 0;\r\n\t            pattern.isOffsetInPixels = (pattern.offset > 0);\r\n\t        }\r\n\t\r\n\t        if(typeof patternDef.endOffset === 'string' && patternDef.endOffset.indexOf('%') != -1) {\r\n\t            pattern.endOffset = parseFloat(patternDef.endOffset) / 100;\r\n\t        } else {\r\n\t            pattern.endOffset = patternDef.endOffset ? parseFloat(patternDef.endOffset) : 0;\r\n\t            pattern.isEndOffsetInPixels = (pattern.endOffset > 0);\r\n\t        }\r\n\t\r\n\t        if(typeof patternDef.repeat === 'string' && patternDef.repeat.indexOf('%') != -1) {\r\n\t            pattern.repeat = parseFloat(patternDef.repeat) / 100;\r\n\t        } else {\r\n\t            pattern.repeat = parseFloat(patternDef.repeat);\r\n\t            pattern.isRepeatInPixels = (pattern.repeat > 0);\r\n\t        }\r\n\t\r\n\t        // TODO: 0 => not pixel dependant => 0%\r\n\t\r\n\t        return(pattern);\r\n\t    },\r\n\t\r\n\t    onAdd: function (map) {\r\n\t        this._map = map;\r\n\t        this._draw();\r\n\t        // listen to zoom changes to redraw pixel-spaced patterns\r\n\t        if(this._isZoomDependant) {\r\n\t            this._map.on('zoomend', this._softRedraw, this);\r\n\t        }\r\n\t    },\r\n\t\r\n\t    onRemove: function (map) {\r\n\t        // remove optional map zoom listener\r\n\t        this._map.off('zoomend', this._softRedraw, this);\r\n\t        this._map = null;\r\n\t        L.LayerGroup.prototype.onRemove.call(this, map);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    * Returns an array of ILayers object\r\n\t    */\r\n\t    _buildSymbols: function(latLngs, symbolFactory, directionPoints) {\r\n\t        var symbols = [];\r\n\t        for(var i=0, l=directionPoints.length; i<l; i++) {\r\n\t            symbols.push(symbolFactory.buildSymbol(directionPoints[i], latLngs, this._map, i, l));\r\n\t        }\r\n\t        return symbols;\r\n\t    },\r\n\t\r\n\t    _getCache: function(pattern, zoom, pathIndex) {\r\n\t        var zoomCache = pattern.cache[zoom];\r\n\t        if(typeof zoomCache === 'undefined') {\r\n\t            pattern.cache[zoom] = [];\r\n\t            return null;\r\n\t        }\r\n\t        return zoomCache[pathIndex];\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    * Select pairs of LatLng and heading angle,\r\n\t    * that define positions and directions of the symbols\r\n\t    * on the path\r\n\t    */\r\n\t    _getDirectionPoints: function(pathIndex, pattern) {\r\n\t        var zoom = this._map.getZoom();\r\n\t        var dirPoints = this._getCache(pattern, zoom, pathIndex);\r\n\t        if(dirPoints) {\r\n\t            return dirPoints;\r\n\t        }\r\n\t\r\n\t        var offset, endOffset, repeat, pathPixelLength = null, latLngs = this._paths[pathIndex];\r\n\t        if(pattern.isOffsetInPixels) {\r\n\t            pathPixelLength =  L.LineUtil.PolylineDecorator.getPixelLength(latLngs, this._map);\r\n\t            offset = pattern.offset/pathPixelLength;\r\n\t        } else {\r\n\t            offset = pattern.offset;\r\n\t        }\r\n\t        if(pattern.isEndOffsetInPixels) {\r\n\t            pathPixelLength = (pathPixelLength !== null) ? pathPixelLength : L.LineUtil.PolylineDecorator.getPixelLength(latLngs, this._map);\r\n\t            endOffset = pattern.endOffset/pathPixelLength;\r\n\t        } else {\r\n\t            endOffset = pattern.endOffset;\r\n\t        }\r\n\t        if(pattern.isRepeatInPixels) {\r\n\t            pathPixelLength = (pathPixelLength !== null) ? pathPixelLength : L.LineUtil.PolylineDecorator.getPixelLength(latLngs, this._map);\r\n\t            repeat = pattern.repeat/pathPixelLength;\r\n\t        } else {\r\n\t            repeat = pattern.repeat;\r\n\t        }\r\n\t        dirPoints = L.LineUtil.PolylineDecorator.projectPatternOnPath(latLngs, offset, endOffset, repeat, this._map);\r\n\t        // save in cache to avoid recomputing this\r\n\t        pattern.cache[zoom][pathIndex] = dirPoints;\r\n\t\r\n\t        return dirPoints;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    * Public redraw, invalidating the cache.\r\n\t    */\r\n\t    redraw: function() {\r\n\t        this._redraw(true);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    * \"Soft\" redraw, called internally for example on zoom changes,\r\n\t    * keeping the cache.\r\n\t    */\r\n\t    _softRedraw: function() {\r\n\t        this._redraw(false);\r\n\t    },\r\n\t\r\n\t    _redraw: function(clearCache) {\r\n\t        if(this._map === null)\r\n\t            return;\r\n\t        this.clearLayers();\r\n\t        if(clearCache) {\r\n\t            for(var i=0; i<this._patterns.length; i++) {\r\n\t                this._patterns[i].cache = [];\r\n\t            }\r\n\t        }\r\n\t        this._draw();\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    * Draw a single pattern\r\n\t    */\r\n\t    _drawPattern: function(pattern) {\r\n\t        var directionPoints, symbols;\r\n\t        for(var i=0; i < this._paths.length; i++) {\r\n\t            directionPoints = this._getDirectionPoints(i, pattern);\r\n\t            symbols = this._buildSymbols(this._paths[i], pattern.symbolFactory, directionPoints);\r\n\t            for(var j=0; j < symbols.length; j++) {\r\n\t                this.addLayer(symbols[j]);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t    * Draw all patterns\r\n\t    */\r\n\t    _draw: function () {\r\n\t        for(var i=0; i<this._patterns.length; i++) {\r\n\t            this._drawPattern(this._patterns[i]);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t/*\r\n\t * Allows compact syntax to be used\r\n\t */\r\n\tL.polylineDecorator = function (paths, options) {\r\n\t    return new L.PolylineDecorator(paths, options);\r\n\t};\r\n\t\n\tL.RotatedMarker = L.Marker.extend({\r\n\t    options: {\r\n\t        angle: 0\r\n\t    },\r\n\t\r\n\t    _setPos: function (pos) {\r\n\t        L.Marker.prototype._setPos.call(this, pos);\r\n\t        \r\n\t        if (L.DomUtil.TRANSFORM) {\r\n\t            // use the CSS transform rule if available\r\n\t            this._icon.style[L.DomUtil.TRANSFORM] += ' rotate(' + this.options.angle + 'deg)';\r\n\t        } else if(L.Browser.ie) {\r\n\t            // fallback for IE6, IE7, IE8\r\n\t            var rad = this.options.angle * (Math.PI / 180),\r\n\t                costheta = Math.cos(rad),\r\n\t                sintheta = Math.sin(rad);\r\n\t            this._icon.style.filter += ' progid:DXImageTransform.Microsoft.Matrix(sizingMethod=\\'auto expand\\', M11=' + \r\n\t                costheta + ', M12=' + (-sintheta) + ', M21=' + sintheta + ', M22=' + costheta + ')';                \r\n\t        }\r\n\t    },\r\n\t    setAngle: function (ang) {\r\n\t        this.options.angle = ang;\r\n\t    }\r\n\t});\r\n\t\r\n\tL.rotatedMarker = function (pos, options) {\r\n\t    return new L.RotatedMarker(pos, options);\r\n\t};\r\n\t\n\t/**\r\n\t* Defines several classes of symbol factories,\r\n\t* to be used with L.PolylineDecorator\r\n\t*/\r\n\t\r\n\tL.Symbol = L.Symbol || {};\r\n\t\r\n\t/**\r\n\t* A simple dash symbol, drawn as a Polyline.\r\n\t* Can also be used for dots, if 'pixelSize' option is given the 0 value.\r\n\t*/\r\n\tL.Symbol.Dash = L.Class.extend({\r\n\t    isZoomDependant: true,\r\n\t    \r\n\t    options: {\r\n\t        pixelSize: 10,\r\n\t        pathOptions: { }\r\n\t    },\r\n\t    \r\n\t    initialize: function (options) {\r\n\t        L.Util.setOptions(this, options);\r\n\t        this.options.pathOptions.clickable = false;\r\n\t    },\r\n\t\r\n\t    buildSymbol: function(dirPoint, latLngs, map, index, total) {\r\n\t        var opts = this.options,\r\n\t            d2r = Math.PI / 180;\r\n\t        \r\n\t        // for a dot, nothing more to compute\r\n\t        if(opts.pixelSize <= 1) {\r\n\t            return new L.Polyline([dirPoint.latLng, dirPoint.latLng], opts.pathOptions);\r\n\t        }\r\n\t        \r\n\t        var midPoint = map.project(dirPoint.latLng);\r\n\t        var angle = (-(dirPoint.heading - 90)) * d2r;\r\n\t        var a = new L.Point(\r\n\t                midPoint.x + opts.pixelSize * Math.cos(angle + Math.PI) / 2,\r\n\t                midPoint.y + opts.pixelSize * Math.sin(angle) / 2\r\n\t            );\r\n\t        // compute second point by central symmetry to avoid unecessary cos/sin\r\n\t        var b = midPoint.add(midPoint.subtract(a));\r\n\t        return new L.Polyline([map.unproject(a), map.unproject(b)], opts.pathOptions);\r\n\t    }\r\n\t});\r\n\t\r\n\tL.Symbol.dash = function (options) {\r\n\t    return new L.Symbol.Dash(options);\r\n\t};\r\n\t\r\n\tL.Symbol.ArrowHead = L.Class.extend({\r\n\t    isZoomDependant: true,\r\n\t    \r\n\t    options: {\r\n\t        polygon: true,\r\n\t        pixelSize: 10,\r\n\t        headAngle: 60,\r\n\t        pathOptions: {\r\n\t            stroke: false,\r\n\t            weight: 2\r\n\t        }\r\n\t    },\r\n\t    \r\n\t    initialize: function (options) {\r\n\t        L.Util.setOptions(this, options);\r\n\t        this.options.pathOptions.clickable = false;\r\n\t    },\r\n\t\r\n\t    buildSymbol: function(dirPoint, latLngs, map, index, total) {\r\n\t        var opts = this.options;\r\n\t        var path;\r\n\t        if(opts.polygon) {\r\n\t            path = new L.Polygon(this._buildArrowPath(dirPoint, map), opts.pathOptions);\r\n\t        } else {\r\n\t            path = new L.Polyline(this._buildArrowPath(dirPoint, map), opts.pathOptions);\r\n\t        }\r\n\t        return path;\r\n\t    },\r\n\t    \r\n\t    _buildArrowPath: function (dirPoint, map) {\r\n\t        var d2r = Math.PI / 180;\r\n\t        var tipPoint = map.project(dirPoint.latLng);\r\n\t        var direction = (-(dirPoint.heading - 90)) * d2r;\r\n\t        var radianArrowAngle = this.options.headAngle / 2 * d2r;\r\n\t        \r\n\t        var headAngle1 = direction + radianArrowAngle,\r\n\t            headAngle2 = direction - radianArrowAngle;\r\n\t        var arrowHead1 = new L.Point(\r\n\t                tipPoint.x - this.options.pixelSize * Math.cos(headAngle1),\r\n\t                tipPoint.y + this.options.pixelSize * Math.sin(headAngle1)),\r\n\t            arrowHead2 = new L.Point(\r\n\t                tipPoint.x - this.options.pixelSize * Math.cos(headAngle2),\r\n\t                tipPoint.y + this.options.pixelSize * Math.sin(headAngle2));\r\n\t\r\n\t        return [\r\n\t            map.unproject(arrowHead1),\r\n\t            dirPoint.latLng,\r\n\t            map.unproject(arrowHead2)\r\n\t        ];\r\n\t    }\r\n\t});\r\n\t\r\n\tL.Symbol.arrowHead = function (options) {\r\n\t    return new L.Symbol.ArrowHead(options);\r\n\t};\r\n\t\r\n\tL.Symbol.Marker = L.Class.extend({\r\n\t    isZoomDependant: false,\r\n\t\r\n\t    options: {\r\n\t        markerOptions: { },\r\n\t        rotate: false\r\n\t    },\r\n\t    \r\n\t    initialize: function (options) {\r\n\t        L.Util.setOptions(this, options);\r\n\t        this.options.markerOptions.clickable = false;\r\n\t        this.options.markerOptions.draggable = false;\r\n\t        this.isZoomDependant = (L.Browser.ie && this.options.rotate);\r\n\t    },\r\n\t\r\n\t    buildSymbol: function(directionPoint, latLngs, map, index, total) {\r\n\t        if(!this.options.rotate) {\r\n\t            return new L.Marker(directionPoint.latLng, this.options.markerOptions);\r\n\t        }\r\n\t        else {\r\n\t            this.options.markerOptions.angle = directionPoint.heading;\r\n\t            return new L.RotatedMarker(directionPoint.latLng, this.options.markerOptions);\r\n\t        }\r\n\t    }\r\n\t});\r\n\t\r\n\tL.Symbol.marker = function (options) {\r\n\t    return new L.Symbol.Marker(options);\r\n\t};\r\n\t\r\n\t\r\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** grits-net-mapper.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 86b4544da83639d210cc\n **/","require \"leaflet-polylinedecorator/leaflet.polylineDecorator.js\"\r\n\r\nL.MapPath = L.Path.extend(\r\n  id: null\r\n  map: null\r\n  smoothFactor: 1.0\r\n  pointList: null\r\n  pathLine: null\r\n  pathLineDecorator: null\r\n  origin: null\r\n  destination: null\r\n  destWAC: null\r\n  miles: null\r\n  origWAC: null\r\n  totalSeats: null\r\n  seats_week: null\r\n  stops: null\r\n  flights: 0\r\n  visible: false\r\n  onAdd: (map) ->\r\n    @show()\r\n    return\r\n  show: ->\r\n    @visible = true\r\n    if @pathLine != null\r\n      @pathLine.addTo @map\r\n    if @pathLineDecorator != null\r\n      @pathLineDecorator.addTo @map\r\n    if @departureAirport != null and @departureAirport.visible == false\r\n      @departureAirport.marker.addTo @map\r\n    if @arrivalAirport != null and @arrivalAirport.visible == false\r\n      @arrivalAirport.marker.addTo @map\r\n    return\r\n  hide: ->\r\n    @visible = false\r\n    if @pathLine != null\r\n      @map.removeLayer @pathLine\r\n    if @pathLineDecorator != null\r\n      @map.removeLayer @pathLineDecorator\r\n    return\r\n  update: (flight) ->\r\n    if flight.departureAirport != null\r\n      @departureAirport = new (L.MapNode)(flight.departureAirport, @map)\r\n    if flight.arrivalAirport != null\r\n      @arrivalAirport = new (L.MapNode)(flight.arrivalAirport, @map)\r\n    if flight.Miles != null\r\n      @miles = flight.Miles\r\n    if flight['Orig WAC']\r\n      @origWAC = flight['Orig WAC']\r\n    if flight.totalSeats != null\r\n      @totalSeats = flight.totalSeats\r\n    if flight['Seats/Week'] != null\r\n      @seats_week = flight['Seats/Week']\r\n    @setPopup()\r\n    return\r\n  initialize: (flight, map) ->\r\n    @map = map\r\n    @visible = true\r\n    @id = flight['_id']\r\n    if flight.departureAirport != null\r\n      @departureAirport = new (L.MapNode)(flight.departureAirport, @map)\r\n    if flight.arrivalAirport != null\r\n      @arrivalAirport = new (L.MapNode)(flight.arrivalAirport, @map)\r\n    @miles = flight.Miles\r\n    @origWAC = flight['Orig WAC']\r\n    @totalSeats = flight.totalSeats\r\n    @seats_week = flight['Seats/Week']\r\n    @stops = flight.Stops\r\n    @pointList = [\r\n      @departureAirport.latlng\r\n      @arrivalAirport.latlng\r\n    ]\r\n    L.MapPaths.addInitializedPath this\r\n    @drawPath()\r\n  midPoint: (points, ud) ->\r\n    latDif = undefined\r\n    midPoint = undefined\r\n    midPoint = []\r\n    latDif = Math.abs(points[0].lat - (points[1].lat))\r\n    if points[0].lat > points[1].lat\r\n      if ud\r\n        midPoint[0] = points[1].lat + latDif / 4\r\n      else\r\n        midPoint[0] = points[0].lat - (latDif / 4)\r\n    else\r\n      if ud\r\n        midPoint[0] = points[1].lat + latDif / 4\r\n      else\r\n        midPoint[0] = points[1].lat - (latDif / 4)\r\n    midPoint[1] = (points[0].lng + points[1].lng) / 2\r\n    midPoint\r\n  calculateArch: ->\r\n    curved = undefined\r\n    line = undefined\r\n    line = 'geometry': 'coordinates': [\r\n      [\r\n        @departureAirport.latlng.lat\r\n        @departureAirport.latlng.lng\r\n      ]\r\n      @midPoint([\r\n        @departureAirport.latlng\r\n        @arrivalAirport.latlng\r\n      ], true)\r\n      [\r\n        @arrivalAirport.latlng.lat\r\n        @arrivalAirport.latlng.lng\r\n      ]\r\n    ]\r\n    curved = turf.bezier(line, 10000, 1)\r\n    @pointList = curved.geometry.coordinates\r\n    @pointList.push @arrivalAirport.latlng\r\n  refresh: ->\r\n    @setPopup()\r\n    @hide()\r\n    @drawPath()\r\n    @show()\r\n  setPopup: ->\r\n    div = undefined\r\n    popup = undefined\r\n    popup = new (L.popup)\r\n    div = L.DomUtil.create('div', '')\r\n    Blaze.renderWithData Template.pathDetails, this, div\r\n    popup.setContent div\r\n    @pathLine.bindPopup popup\r\n  setStyle: (color, weight) ->\r\n    @color = color\r\n    @weight = weight\r\n  drawPath: ->\r\n    archPos = undefined\r\n    i = undefined\r\n    len = undefined\r\n    mapPath = undefined\r\n    ref = undefined\r\n    @visible = true\r\n    archPos = []\r\n    ref = L.MapPaths.mapPaths\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      mapPath = ref[i]\r\n      if mapPath != this\r\n        if mapPath.departureAirport.equals(@departureAirport) and mapPath.arrivalAirport.equals(@arrivalAirport)\r\n          archPos[mapPath.archPosition] = true\r\n      i++\r\n    @calculateArch archPos\r\n    @pathLine = new (L.Polyline)(@pointList,\r\n      color: @color\r\n      weight: @weight\r\n      opacity: 0.8\r\n      smoothFactor: 1)\r\n    @pathLineDecorator = L.polylineDecorator(@pathLine, patterns: [ {\r\n      offset: '50px'\r\n      repeat: '100px'\r\n      symbol: new (L.Symbol.ArrowHead)(\r\n        pixelSize: 20\r\n        pathOptions: color: @color)\r\n    } ])\r\n    @setPopup()\r\n)\r\n\r\nL.mapPath = (flight, map) ->\r\n  new (L.MapPath)(flight, map)\r\n\r\nL.MapPaths =\r\n  mapPaths: []\r\n  factors: []\r\n  getLayerGroup: ->\r\n    L.layerGroup @mapPaths\r\n  getFactorById: (id) ->\r\n    factor = undefined\r\n    i = undefined\r\n    len = undefined\r\n    ref = undefined\r\n    ref = @factors\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      factor = ref[i]\r\n      if factor._id == id\r\n        return factor\r\n      i++\r\n    false\r\n  getMapPathByFactor: (factor) ->\r\n    i = undefined\r\n    len = undefined\r\n    ref = undefined\r\n    tempMapPath = undefined\r\n    ref = @mapPaths\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      tempMapPath = ref[i]\r\n      if tempMapPath.departureAirport.id == factor['departureAirport']._id and tempMapPath.arrivalAirport.id == factor['arrivalAirport']._id\r\n        return tempMapPath\r\n      i++\r\n    false\r\n  addInitializedPath: (mapPath) ->\r\n    @mapPaths.push mapPath\r\n  addFactor: (id, factor, map) ->\r\n    existingFactor = undefined\r\n    path = undefined\r\n    existingFactor = @getFactorById(id)\r\n    if existingFactor != false\r\n      return @getMapPathByFactor(existingFactor)\r\n    factor._id = id\r\n    path = @getMapPathByFactor(factor)\r\n    if path != false\r\n      path.totalSeats += factor['totalSeats']\r\n    else if path == false\r\n      path = new (L.MapPath)(factor, map).addTo(map)\r\n      path.totalSeats = factor['totalSeats']\r\n    @factors.push factor\r\n    path.flights++\r\n    path.refresh()\r\n    path\r\n  removeFactor: (id) ->\r\n    d1 = undefined\r\n    d2 = undefined\r\n    factor = undefined\r\n    i = undefined\r\n    len = undefined\r\n    o1 = undefined\r\n    o2 = undefined\r\n    path = undefined\r\n    ref = undefined\r\n    removeDest = undefined\r\n    removeOrig = undefined\r\n    tempMapPath = undefined\r\n    factor = @getFactorById(id)\r\n    if factor == false\r\n      return false\r\n    @factors.splice @factors.indexOf(factor), 1\r\n    path = @getMapPathByFactor(factor)\r\n    path.totalSeats -= factor['totalSeats']\r\n    path.flights--\r\n    if path.flights is 0\r\n      path.arrivalAirport.hide()\r\n      path.departureAirport.hide()\r\n      path.hide()\r\n      return false\r\n    else\r\n      path.show()\r\n      {\r\n        'path': path\r\n        'factor': factor\r\n      }\r\n  updatePath: (id, mapPath, map) ->\r\n    i = undefined\r\n    len = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    tempMapPath = undefined\r\n    ref = @mapPaths\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      tempMapPath = ref[i]\r\n      if tempMapPath.id == id\r\n        tempMapPath.hide()\r\n        tempMapPath.update mapPath\r\n        results.push tempMapPath.show()\r\n      else\r\n        results.push undefined\r\n      i++\r\n    results\r\n  showPath: (mapPath) ->\r\n    mapPath.show()\r\n  hidePath: (mapPath) ->\r\n    mapPath.hide()\r\n  hideAllPaths: ->\r\n    i = undefined\r\n    len = undefined\r\n    path = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    ref = @mapPaths\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      path = ref[i]\r\n      results.push path.hide()\r\n      i++\r\n    results\r\n  showAllPaths: ->\r\n    i = undefined\r\n    len = undefined\r\n    path = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    ref = @mapPaths\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      path = ref[i]\r\n      results.push path.show()\r\n      i++\r\n    results\r\n  hideAllNodes: ->\r\n    i = undefined\r\n    len = undefined\r\n    node = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    ref = L.MapNodes.mapNodes\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      node = ref[i]\r\n      results.push node.hide()\r\n      i++\r\n    results\r\n  showAllNodes: ->\r\n    L.MapNodes.showAllNodes()\r\n  hideBetween: (mapNodeA, mapNodeB) ->\r\n    i = undefined\r\n    len = undefined\r\n    mapPath = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    ref = @mapPaths\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      mapPath = ref[i]\r\n      if mapPath.departureAirport == mapNodeA and mapPath.arrivalAirport == mapNodeB\r\n        mapPath.hide()\r\n      if mapPath.departureAirport == mapNodeB and mapPath.arrivalAirport == mapNodeA\r\n        results.push mapPath.hide()\r\n      else\r\n        results.push undefined\r\n      i++\r\n    results\r\nL.MapNode = L.Path.extend(\r\n  visible: false\r\n  latlng: null\r\n  city: null\r\n  state: null\r\n  stateName: null\r\n  country: null\r\n  countryName: null\r\n  globalRegion: null\r\n  WAC: null\r\n  notes: null\r\n  code: null\r\n  name: null\r\n  key: null\r\n  map: null\r\n  marker: null\r\n  onAdd: (map) ->\r\n    if @marker != null\r\n      @marker.addTo map\r\n    return\r\n  onRemove: (map) ->\r\n    map.removeLayer @marker\r\n    return\r\n  setPopup: ->\r\n    div = undefined\r\n    popup = undefined\r\n    popup = new (L.popup)\r\n    div = L.DomUtil.create('div', '')\r\n    Blaze.renderWithData Template.nodeDetails, this, div\r\n    popup.setContent div\r\n    @marker.bindPopup popup\r\n  initialize: (node, map) ->\r\n    i = undefined\r\n    len = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    @map = map\r\n    @id = node['_id']\r\n    @name = node.name\r\n    @city = node.city\r\n    @state = node.state\r\n    @stateName = node.stateName\r\n    @country = node.country\r\n    @countryName = node.countryName\r\n    @globalRegion = node.globalRegion\r\n    @notes = node.notes\r\n    @WAC = node.WAC\r\n    @key = node.key\r\n    @latlng = new (L.LatLng)(node.loc.coordinates[1], node.loc.coordinates[0])\r\n    if !L.MapNodes.contains(this)\r\n      @marker = L.marker(@latlng)\r\n      @marker.on 'click', (e) ->\r\n        Template.map.nodeEvent L.MapNodes.getNodeByMarker(e.target._leaflet_id)\r\n      L.MapNodes.addInitializedNode this\r\n      @setPopup()\r\n    else\r\n      ref = L.MapNodes.mapNodes\r\n      results = []\r\n      i = 0\r\n      len = ref.length\r\n      while i < len\r\n        node = ref[i]\r\n        if node.id == @id\r\n          results.push @marker = node.marker\r\n        else\r\n          results.push undefined\r\n        i++\r\n      results\r\n  equals: (otherNode) ->\r\n    otherNode.latlng.lat == @latlng.lat and otherNode.latlng.lng == @latlng.lng\r\n  hide: ->\r\n    @visible = false\r\n    @map.removeLayer @marker\r\n  show: ->\r\n    @visible = true\r\n    @marker = L.marker(@latlng)\r\n    @setPopup()\r\n)\r\nL.MapNodes =\r\n  selectedNode: null\r\n  mapNodes: []\r\n  getNodeByMarker: (markerId) ->\r\n    for node in @mapNodes\r\n      if node.marker._leaflet_id is markerId\r\n        return node\r\n    return false\r\n  getLayerGroup: ->\r\n    L.layerGroup @mapNodes\r\n  addInitializedNode: (node) ->\r\n    @mapNodes.push node\r\n  nodeClickEvent: (node) ->\r\n    alert node.id\r\n  addNode: (mapNode) ->\r\n    exists = undefined\r\n    i = undefined\r\n    len = undefined\r\n    ref = undefined\r\n    tempMapNode = undefined\r\n    exists = false\r\n    ref = @mapNodes\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      tempMapNode = ref[i]\r\n      if tempMapNode.key == mapNode['_id']\r\n        exists = true\r\n      i++\r\n    if !exists\r\n      return new (L.MapNode)(mapNode, @map)\r\n    return\r\n  removeNode: (id) ->\r\n    i = undefined\r\n    len = undefined\r\n    ref = undefined\r\n    tempMapNode = undefined\r\n    ref = @mapNodes\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      tempMapNode = ref[i]\r\n      if tempMapNode.id == id\r\n        tempMapNode.hide()\r\n        @mapNodes.splice @mapNodes.indexOf(tempMapNode), 1\r\n        return\r\n      i++\r\n    return\r\n  updateNode: (mapNode) ->\r\n    i = undefined\r\n    len = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    tempMapNode = undefined\r\n    ref = @mapNodes\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      tempMapNode = ref[i]\r\n      if tempMapNode.id == tempMapNode['_id']\r\n        tempMapNode.hide()\r\n        tempMapNode.initialize mapNode, @map\r\n        results.push tempMapNode.show()\r\n      else\r\n        results.push undefined\r\n      i++\r\n    results\r\n  contains: (node) ->\r\n    i = undefined\r\n    len = undefined\r\n    mapNode = undefined\r\n    mapNodesContains = undefined\r\n    ref = undefined\r\n    mapNodesContains = false\r\n    ref = @mapNodes\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      mapNode = ref[i]\r\n      if mapNode.id == node.id\r\n        mapNodesContains = true\r\n      i++\r\n    mapNodesContains\r\n  mapNodeCount: ->\r\n    @mapNodes.length\r\n  hideNode: (node) ->\r\n    node.hide()\r\n  showNode: (node) ->\r\n    node.show()\r\n  hideAllNodes: ->\r\n    i = undefined\r\n    len = undefined\r\n    node = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    ref = @mapNodes\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      node = ref[i]\r\n      results.push node.hide()\r\n      i++\r\n    results\r\n  showAllNodes: ->\r\n    i = undefined\r\n    len = undefined\r\n    node = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    ref = @mapNodes\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      node = ref[i]\r\n      results.push node.show()\r\n      i++\r\n    results\r\n\r\nL.mapNode = (node, map) ->\r\n  new (L.MapNode)(node, map)\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/grits-net-mapper.coffee\n **/","\r\nL.LineUtil.PolylineDecorator = {\r\n    computeAngle: function(a, b) {\r\n        return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI) + 90;\r\n    },\r\n\r\n    getPointPathPixelLength: function(pts) {\r\n        var nbPts = pts.length;\r\n        if(nbPts < 2) {\r\n            return 0;\r\n        }\r\n        var dist = 0,\r\n            prevPt = pts[0],\r\n            pt;\r\n        for(var i=1; i<nbPts; i++) {\r\n            dist += prevPt.distanceTo(pt = pts[i]);\r\n            prevPt = pt;\r\n        } \r\n        return dist;\r\n    },\r\n\r\n    getPixelLength: function(pl, map) {\r\n        var ll = (pl instanceof L.Polyline) ? pl.getLatLngs() : pl,\r\n            nbPts = ll.length;\r\n        if(nbPts < 2) {\r\n            return 0;\r\n        }\r\n        var dist = 0,\r\n            prevPt = map.project(ll[0]), pt; \r\n        for(var i=1; i<nbPts; i++) {\r\n            dist += prevPt.distanceTo(pt = map.project(ll[i]));\r\n            prevPt = pt;\r\n        } \r\n        return dist;\r\n    },\r\n\r\n    /**\r\n    * path: array of L.LatLng\r\n    * offsetRatio: the ratio of the total pixel length where the pattern will start\r\n    * endOffsetRatio: the ratio of the total pixel length where the pattern will end\r\n    * repeatRatio: the ratio of the total pixel length between two points of the pattern \r\n    * map: the map, to access the current projection state\r\n    */\r\n    projectPatternOnPath: function (path, offsetRatio, endOffsetRatio, repeatRatio, map) {\r\n        var pathAsPoints = [], i;\r\n\r\n        for(i=0, l=path.length; i<l; i++) {\r\n            pathAsPoints[i] = map.project(path[i]);\r\n        }\r\n        // project the pattern as pixel points\r\n        var pattern = this.projectPatternOnPointPath(pathAsPoints, offsetRatio, endOffsetRatio, repeatRatio);\r\n        // and convert it to latlngs;\r\n        for(i=0, l=pattern.length; i<l; i++) {\r\n            pattern[i].latLng = map.unproject(pattern[i].pt);\r\n        }        \r\n        return pattern;\r\n    },\r\n    \r\n    projectPatternOnPointPath: function (pts, offsetRatio, endOffsetRatio, repeatRatio) {\r\n        var positions = [];\r\n        // 1. compute the absolute interval length in pixels\r\n        var repeatIntervalLength = this.getPointPathPixelLength(pts) * repeatRatio;\r\n        // 2. find the starting point by using the offsetRatio and find the last pixel using endOffsetRatio\r\n        var previous = this.interpolateOnPointPath(pts, offsetRatio);\r\n        var endOffsetPixels = endOffsetRatio > 0 ? this.getPointPathPixelLength(pts) * endOffsetRatio : 0;\r\n        \r\n        positions.push(previous);\r\n        if(repeatRatio > 0) {\r\n            // 3. consider only the rest of the path, starting at the previous point\r\n            var remainingPath = pts;\r\n            remainingPath = remainingPath.slice(previous.predecessor);\r\n            \r\n            remainingPath[0] = previous.pt;\r\n            var remainingLength = this.getPointPathPixelLength(remainingPath);\r\n            \r\n            // 4. project as a ratio of the remaining length,\r\n            // and repeat while there is room for another point of the pattern\r\n\r\n            while(repeatIntervalLength <= remainingLength-endOffsetPixels) {\r\n                previous = this.interpolateOnPointPath(remainingPath, repeatIntervalLength/remainingLength);\r\n                positions.push(previous);\r\n                remainingPath = remainingPath.slice(previous.predecessor);\r\n                remainingPath[0] = previous.pt;\r\n                remainingLength = this.getPointPathPixelLength(remainingPath);\r\n            }\r\n        }\r\n        return positions;\r\n    },\r\n\r\n    /**\r\n    * pts: array of L.Point\r\n    * ratio: the ratio of the total length where the point should be computed\r\n    * Returns null if ll has less than 2 LatLng, or an object with the following properties:\r\n    *    latLng: the LatLng of the interpolated point\r\n    *    predecessor: the index of the previous vertex on the path\r\n    *    heading: the heading of the path at this point, in degrees\r\n    */\r\n    interpolateOnPointPath: function (pts, ratio) {\r\n        var nbVertices = pts.length;\r\n\r\n        if (nbVertices < 2) {\r\n            return null;\r\n        }\r\n        // easy limit cases: ratio negative/zero => first vertex\r\n        if (ratio <= 0) {\r\n            return {\r\n                pt: pts[0],\r\n                predecessor: 0,\r\n                heading: this.computeAngle(pts[0], pts[1])\r\n            };\r\n        }\r\n        // ratio >=1 => last vertex\r\n        if (ratio >= 1) {\r\n            return {\r\n                pt: pts[nbVertices - 1],\r\n                predecessor: nbVertices - 1,\r\n                heading: this.computeAngle(pts[nbVertices - 2], pts[nbVertices - 1])\r\n            };\r\n        }\r\n        // 1-segment-only path => direct linear interpolation\r\n        if (nbVertices == 2) {\r\n            return {\r\n                pt: this.interpolateBetweenPoints(pts[0], pts[1], ratio),\r\n                predecessor: 0,\r\n                heading: this.computeAngle(pts[0], pts[1])\r\n            };\r\n        }\r\n            \r\n        var pathLength = this.getPointPathPixelLength(pts);\r\n        var a = pts[0], b = a,\r\n            ratioA = 0, ratioB = 0,\r\n            distB = 0;\r\n        // follow the path segments until we find the one\r\n        // on which the point must lie => [ab] \r\n        var i = 1;\r\n        for (; i < nbVertices && ratioB < ratio; i++) {\r\n            a = b;\r\n            ratioA = ratioB;\r\n            b = pts[i];\r\n            distB += a.distanceTo(b);\r\n            ratioB = distB / pathLength;\r\n        }\r\n\r\n        // compute the ratio relative to the segment [ab]\r\n        var segmentRatio = (ratio - ratioA) / (ratioB - ratioA);\r\n\r\n        return {\r\n            pt: this.interpolateBetweenPoints(a, b, segmentRatio),\r\n            predecessor: i-2,\r\n            heading: this.computeAngle(a, b)\r\n        };\r\n    },\r\n    \r\n    /**\r\n    * Finds the point which lies on the segment defined by points A and B,\r\n    * at the given ratio of the distance from A to B, by linear interpolation. \r\n    */\r\n    interpolateBetweenPoints: function (ptA, ptB, ratio) {\r\n        if(ptB.x != ptA.x) {\r\n            return new L.Point(\r\n                (ptA.x * (1 - ratio)) + (ratio * ptB.x),\r\n                (ptA.y * (1 - ratio)) + (ratio * ptB.y)\r\n            );\r\n        }\r\n        // special case where points lie on the same vertical axis\r\n        return new L.Point(ptA.x, ptA.y + (ptB.y - ptA.y) * ratio);\r\n    }\r\n};\n\r\nL.PolylineDecorator = L.LayerGroup.extend({\r\n    options: {\r\n        patterns: []\r\n    },\r\n\r\n    initialize: function(paths, options) {\r\n        L.LayerGroup.prototype.initialize.call(this);\r\n        L.Util.setOptions(this, options);\r\n        this._map = null;\r\n        this._initPaths(paths);\r\n        this._initPatterns();\r\n    },\r\n\r\n    /**\r\n    * Deals with all the different cases. p can be one of these types:\r\n    * array of LatLng, array of 2-number arrays, Polyline, Polygon,\r\n    * array of one of the previous.\r\n    */\r\n    _initPaths: function(p) {\r\n        this._paths = [];\r\n        var isPolygon = false;\r\n        if(p instanceof L.Polyline) {\r\n            this._initPath(p.getLatLngs(), (p instanceof L.Polygon));\r\n        } else if(L.Util.isArray(p) && p.length > 0) {\r\n            if(p[0] instanceof L.Polyline) {\r\n                for(var i=0; i<p.length; i++) {\r\n                    this._initPath(p[i].getLatLngs(), (p[i] instanceof L.Polygon));\r\n                }\r\n            } else {\r\n                this._initPath(p);\r\n            }\r\n        }\r\n    },\r\n\r\n    _isCoordArray: function(ll) {\r\n        return(L.Util.isArray(ll) && ll.length > 0 && (\r\n            ll[0] instanceof L.LatLng ||\r\n            (L.Util.isArray(ll[0]) && ll[0].length == 2 && typeof ll[0][0] === 'number')\r\n        ));\r\n    },\r\n\r\n    _initPath: function(path, isPolygon) {\r\n        var latLngs;\r\n        // It may still be an array of array of coordinates\r\n        // (ex: polygon with rings)\r\n        if(this._isCoordArray(path)) {\r\n            latLngs = [path];\r\n        } else {\r\n            latLngs = path;\r\n        }\r\n        for(var i=0; i<latLngs.length; i++) {\r\n            // As of Leaflet >= v0.6, last polygon vertex (=first) isn't repeated.\r\n            // Our algorithm needs it, so we add it back explicitly.\r\n            if(isPolygon) {\r\n                latLngs[i].push(latLngs[i][0]);\r\n            }\r\n            this._paths.push(latLngs[i]);\r\n        }\r\n    },\r\n\r\n    _initPatterns: function() {\r\n        this._isZoomDependant = false;\r\n        this._patterns = [];\r\n        var pattern;\r\n        // parse pattern definitions and precompute some values\r\n        for(var i=0;i<this.options.patterns.length;i++) {\r\n            pattern = this._parsePatternDef(this.options.patterns[i]);\r\n            this._patterns.push(pattern);\r\n            // determines if we have to recompute the pattern on each zoom change\r\n            this._isZoomDependant = this._isZoomDependant ||\r\n                pattern.isOffsetInPixels ||\r\n                pattern.isEndOffsetInPixels ||\r\n                pattern.isRepeatInPixels ||\r\n                pattern.symbolFactory.isZoomDependant;\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Changes the patterns used by this decorator\r\n    * and redraws the new one.\r\n    */\r\n    setPatterns: function(patterns) {\r\n        this.options.patterns = patterns;\r\n        this._initPatterns();\r\n        this._softRedraw();\r\n    },\r\n\r\n    /**\r\n    * Changes the patterns used by this decorator\r\n    * and redraws the new one.\r\n    */\r\n    setPaths: function(paths) {\r\n        this._initPaths(paths);\r\n        this.redraw();\r\n    },\r\n\r\n    /**\r\n    * Parse the pattern definition\r\n    */\r\n    _parsePatternDef: function(patternDef, latLngs) {\r\n        var pattern = {\r\n            cache: [],\r\n            symbolFactory: patternDef.symbol,\r\n            isOffsetInPixels: false,\r\n            isEndOffsetInPixels: false,\r\n            isRepeatInPixels: false\r\n        };\r\n\r\n        // Parse offset and repeat values, managing the two cases:\r\n        // absolute (in pixels) or relative (in percentage of the polyline length)\r\n        if(typeof patternDef.offset === 'string' && patternDef.offset.indexOf('%') != -1) {\r\n            pattern.offset = parseFloat(patternDef.offset) / 100;\r\n        } else {\r\n            pattern.offset = patternDef.offset ? parseFloat(patternDef.offset) : 0;\r\n            pattern.isOffsetInPixels = (pattern.offset > 0);\r\n        }\r\n\r\n        if(typeof patternDef.endOffset === 'string' && patternDef.endOffset.indexOf('%') != -1) {\r\n            pattern.endOffset = parseFloat(patternDef.endOffset) / 100;\r\n        } else {\r\n            pattern.endOffset = patternDef.endOffset ? parseFloat(patternDef.endOffset) : 0;\r\n            pattern.isEndOffsetInPixels = (pattern.endOffset > 0);\r\n        }\r\n\r\n        if(typeof patternDef.repeat === 'string' && patternDef.repeat.indexOf('%') != -1) {\r\n            pattern.repeat = parseFloat(patternDef.repeat) / 100;\r\n        } else {\r\n            pattern.repeat = parseFloat(patternDef.repeat);\r\n            pattern.isRepeatInPixels = (pattern.repeat > 0);\r\n        }\r\n\r\n        // TODO: 0 => not pixel dependant => 0%\r\n\r\n        return(pattern);\r\n    },\r\n\r\n    onAdd: function (map) {\r\n        this._map = map;\r\n        this._draw();\r\n        // listen to zoom changes to redraw pixel-spaced patterns\r\n        if(this._isZoomDependant) {\r\n            this._map.on('zoomend', this._softRedraw, this);\r\n        }\r\n    },\r\n\r\n    onRemove: function (map) {\r\n        // remove optional map zoom listener\r\n        this._map.off('zoomend', this._softRedraw, this);\r\n        this._map = null;\r\n        L.LayerGroup.prototype.onRemove.call(this, map);\r\n    },\r\n\r\n    /**\r\n    * Returns an array of ILayers object\r\n    */\r\n    _buildSymbols: function(latLngs, symbolFactory, directionPoints) {\r\n        var symbols = [];\r\n        for(var i=0, l=directionPoints.length; i<l; i++) {\r\n            symbols.push(symbolFactory.buildSymbol(directionPoints[i], latLngs, this._map, i, l));\r\n        }\r\n        return symbols;\r\n    },\r\n\r\n    _getCache: function(pattern, zoom, pathIndex) {\r\n        var zoomCache = pattern.cache[zoom];\r\n        if(typeof zoomCache === 'undefined') {\r\n            pattern.cache[zoom] = [];\r\n            return null;\r\n        }\r\n        return zoomCache[pathIndex];\r\n    },\r\n\r\n    /**\r\n    * Select pairs of LatLng and heading angle,\r\n    * that define positions and directions of the symbols\r\n    * on the path\r\n    */\r\n    _getDirectionPoints: function(pathIndex, pattern) {\r\n        var zoom = this._map.getZoom();\r\n        var dirPoints = this._getCache(pattern, zoom, pathIndex);\r\n        if(dirPoints) {\r\n            return dirPoints;\r\n        }\r\n\r\n        var offset, endOffset, repeat, pathPixelLength = null, latLngs = this._paths[pathIndex];\r\n        if(pattern.isOffsetInPixels) {\r\n            pathPixelLength =  L.LineUtil.PolylineDecorator.getPixelLength(latLngs, this._map);\r\n            offset = pattern.offset/pathPixelLength;\r\n        } else {\r\n            offset = pattern.offset;\r\n        }\r\n        if(pattern.isEndOffsetInPixels) {\r\n            pathPixelLength = (pathPixelLength !== null) ? pathPixelLength : L.LineUtil.PolylineDecorator.getPixelLength(latLngs, this._map);\r\n            endOffset = pattern.endOffset/pathPixelLength;\r\n        } else {\r\n            endOffset = pattern.endOffset;\r\n        }\r\n        if(pattern.isRepeatInPixels) {\r\n            pathPixelLength = (pathPixelLength !== null) ? pathPixelLength : L.LineUtil.PolylineDecorator.getPixelLength(latLngs, this._map);\r\n            repeat = pattern.repeat/pathPixelLength;\r\n        } else {\r\n            repeat = pattern.repeat;\r\n        }\r\n        dirPoints = L.LineUtil.PolylineDecorator.projectPatternOnPath(latLngs, offset, endOffset, repeat, this._map);\r\n        // save in cache to avoid recomputing this\r\n        pattern.cache[zoom][pathIndex] = dirPoints;\r\n\r\n        return dirPoints;\r\n    },\r\n\r\n    /**\r\n    * Public redraw, invalidating the cache.\r\n    */\r\n    redraw: function() {\r\n        this._redraw(true);\r\n    },\r\n\r\n    /**\r\n    * \"Soft\" redraw, called internally for example on zoom changes,\r\n    * keeping the cache.\r\n    */\r\n    _softRedraw: function() {\r\n        this._redraw(false);\r\n    },\r\n\r\n    _redraw: function(clearCache) {\r\n        if(this._map === null)\r\n            return;\r\n        this.clearLayers();\r\n        if(clearCache) {\r\n            for(var i=0; i<this._patterns.length; i++) {\r\n                this._patterns[i].cache = [];\r\n            }\r\n        }\r\n        this._draw();\r\n    },\r\n\r\n    /**\r\n    * Draw a single pattern\r\n    */\r\n    _drawPattern: function(pattern) {\r\n        var directionPoints, symbols;\r\n        for(var i=0; i < this._paths.length; i++) {\r\n            directionPoints = this._getDirectionPoints(i, pattern);\r\n            symbols = this._buildSymbols(this._paths[i], pattern.symbolFactory, directionPoints);\r\n            for(var j=0; j < symbols.length; j++) {\r\n                this.addLayer(symbols[j]);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Draw all patterns\r\n    */\r\n    _draw: function () {\r\n        for(var i=0; i<this._patterns.length; i++) {\r\n            this._drawPattern(this._patterns[i]);\r\n        }\r\n    }\r\n});\r\n/*\r\n * Allows compact syntax to be used\r\n */\r\nL.polylineDecorator = function (paths, options) {\r\n    return new L.PolylineDecorator(paths, options);\r\n};\r\n\nL.RotatedMarker = L.Marker.extend({\r\n    options: {\r\n        angle: 0\r\n    },\r\n\r\n    _setPos: function (pos) {\r\n        L.Marker.prototype._setPos.call(this, pos);\r\n        \r\n        if (L.DomUtil.TRANSFORM) {\r\n            // use the CSS transform rule if available\r\n            this._icon.style[L.DomUtil.TRANSFORM] += ' rotate(' + this.options.angle + 'deg)';\r\n        } else if(L.Browser.ie) {\r\n            // fallback for IE6, IE7, IE8\r\n            var rad = this.options.angle * (Math.PI / 180),\r\n                costheta = Math.cos(rad),\r\n                sintheta = Math.sin(rad);\r\n            this._icon.style.filter += ' progid:DXImageTransform.Microsoft.Matrix(sizingMethod=\\'auto expand\\', M11=' + \r\n                costheta + ', M12=' + (-sintheta) + ', M21=' + sintheta + ', M22=' + costheta + ')';                \r\n        }\r\n    },\r\n    setAngle: function (ang) {\r\n        this.options.angle = ang;\r\n    }\r\n});\r\n\r\nL.rotatedMarker = function (pos, options) {\r\n    return new L.RotatedMarker(pos, options);\r\n};\r\n\n/**\r\n* Defines several classes of symbol factories,\r\n* to be used with L.PolylineDecorator\r\n*/\r\n\r\nL.Symbol = L.Symbol || {};\r\n\r\n/**\r\n* A simple dash symbol, drawn as a Polyline.\r\n* Can also be used for dots, if 'pixelSize' option is given the 0 value.\r\n*/\r\nL.Symbol.Dash = L.Class.extend({\r\n    isZoomDependant: true,\r\n    \r\n    options: {\r\n        pixelSize: 10,\r\n        pathOptions: { }\r\n    },\r\n    \r\n    initialize: function (options) {\r\n        L.Util.setOptions(this, options);\r\n        this.options.pathOptions.clickable = false;\r\n    },\r\n\r\n    buildSymbol: function(dirPoint, latLngs, map, index, total) {\r\n        var opts = this.options,\r\n            d2r = Math.PI / 180;\r\n        \r\n        // for a dot, nothing more to compute\r\n        if(opts.pixelSize <= 1) {\r\n            return new L.Polyline([dirPoint.latLng, dirPoint.latLng], opts.pathOptions);\r\n        }\r\n        \r\n        var midPoint = map.project(dirPoint.latLng);\r\n        var angle = (-(dirPoint.heading - 90)) * d2r;\r\n        var a = new L.Point(\r\n                midPoint.x + opts.pixelSize * Math.cos(angle + Math.PI) / 2,\r\n                midPoint.y + opts.pixelSize * Math.sin(angle) / 2\r\n            );\r\n        // compute second point by central symmetry to avoid unecessary cos/sin\r\n        var b = midPoint.add(midPoint.subtract(a));\r\n        return new L.Polyline([map.unproject(a), map.unproject(b)], opts.pathOptions);\r\n    }\r\n});\r\n\r\nL.Symbol.dash = function (options) {\r\n    return new L.Symbol.Dash(options);\r\n};\r\n\r\nL.Symbol.ArrowHead = L.Class.extend({\r\n    isZoomDependant: true,\r\n    \r\n    options: {\r\n        polygon: true,\r\n        pixelSize: 10,\r\n        headAngle: 60,\r\n        pathOptions: {\r\n            stroke: false,\r\n            weight: 2\r\n        }\r\n    },\r\n    \r\n    initialize: function (options) {\r\n        L.Util.setOptions(this, options);\r\n        this.options.pathOptions.clickable = false;\r\n    },\r\n\r\n    buildSymbol: function(dirPoint, latLngs, map, index, total) {\r\n        var opts = this.options;\r\n        var path;\r\n        if(opts.polygon) {\r\n            path = new L.Polygon(this._buildArrowPath(dirPoint, map), opts.pathOptions);\r\n        } else {\r\n            path = new L.Polyline(this._buildArrowPath(dirPoint, map), opts.pathOptions);\r\n        }\r\n        return path;\r\n    },\r\n    \r\n    _buildArrowPath: function (dirPoint, map) {\r\n        var d2r = Math.PI / 180;\r\n        var tipPoint = map.project(dirPoint.latLng);\r\n        var direction = (-(dirPoint.heading - 90)) * d2r;\r\n        var radianArrowAngle = this.options.headAngle / 2 * d2r;\r\n        \r\n        var headAngle1 = direction + radianArrowAngle,\r\n            headAngle2 = direction - radianArrowAngle;\r\n        var arrowHead1 = new L.Point(\r\n                tipPoint.x - this.options.pixelSize * Math.cos(headAngle1),\r\n                tipPoint.y + this.options.pixelSize * Math.sin(headAngle1)),\r\n            arrowHead2 = new L.Point(\r\n                tipPoint.x - this.options.pixelSize * Math.cos(headAngle2),\r\n                tipPoint.y + this.options.pixelSize * Math.sin(headAngle2));\r\n\r\n        return [\r\n            map.unproject(arrowHead1),\r\n            dirPoint.latLng,\r\n            map.unproject(arrowHead2)\r\n        ];\r\n    }\r\n});\r\n\r\nL.Symbol.arrowHead = function (options) {\r\n    return new L.Symbol.ArrowHead(options);\r\n};\r\n\r\nL.Symbol.Marker = L.Class.extend({\r\n    isZoomDependant: false,\r\n\r\n    options: {\r\n        markerOptions: { },\r\n        rotate: false\r\n    },\r\n    \r\n    initialize: function (options) {\r\n        L.Util.setOptions(this, options);\r\n        this.options.markerOptions.clickable = false;\r\n        this.options.markerOptions.draggable = false;\r\n        this.isZoomDependant = (L.Browser.ie && this.options.rotate);\r\n    },\r\n\r\n    buildSymbol: function(directionPoint, latLngs, map, index, total) {\r\n        if(!this.options.rotate) {\r\n            return new L.Marker(directionPoint.latLng, this.options.markerOptions);\r\n        }\r\n        else {\r\n            this.options.markerOptions.angle = directionPoint.heading;\r\n            return new L.RotatedMarker(directionPoint.latLng, this.options.markerOptions);\r\n        }\r\n    }\r\n});\r\n\r\nL.Symbol.marker = function (options) {\r\n    return new L.Symbol.Marker(options);\r\n};\r\n\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/leaflet-polylinedecorator/leaflet.polylineDecorator.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}