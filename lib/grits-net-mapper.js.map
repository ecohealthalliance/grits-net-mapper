{"version":3,"sources":["webpack:///webpack/bootstrap 86b4544da83639d210cc","webpack:///./src/grits-net-mapper.coffee","webpack:///./~/leaflet-polylinedecorator/leaflet.polylineDecorator.js"],"names":[],"mappings":"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AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA,mCAAkC,KAAK;AACvC;AACA,U;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,kCAAkC;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,6BAA4B,YAAY;AACxC;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,qBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,qBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,+CAA8C,KAAK;AACnD;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,yBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,qBAAoB,wBAAwB;AAC5C;AACA;AACA,yBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,qBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,qG;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB;AACtB,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAwB,EAAE;AAC1B;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA","file":"grits-net-mapper.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 86b4544da83639d210cc\n **/","require \"leaflet-polylinedecorator/leaflet.polylineDecorator.js\"\r\n\r\nL.MapPath = L.Path.extend(\r\n  id: null\r\n  map: null\r\n  smoothFactor: 1.0\r\n  pointList: null\r\n  pathLine: null\r\n  pathLineDecorator: null\r\n  origin: null\r\n  destination: null\r\n  destWAC: null\r\n  miles: null\r\n  origWAC: null\r\n  totalSeats: null\r\n  seats_week: null\r\n  stops: null\r\n  flights: 0\r\n  visible: false\r\n  onAdd: (map) ->\r\n    @show()\r\n    return\r\n  show: ->\r\n    @visible = true\r\n    if @pathLine != null\r\n      @pathLine.addTo @map\r\n    if @pathLineDecorator != null\r\n      @pathLineDecorator.addTo @map\r\n    if @departureAirport != null and @departureAirport.visible == false\r\n      @departureAirport.marker.addTo @map\r\n    if @arrivalAirport != null and @arrivalAirport.visible == false\r\n      @arrivalAirport.marker.addTo @map\r\n    return\r\n  hide: ->\r\n    @visible = false\r\n    if @pathLine != null\r\n      @map.removeLayer @pathLine\r\n    if @pathLineDecorator != null\r\n      @map.removeLayer @pathLineDecorator\r\n    return\r\n  update: (flight) ->\r\n    if flight.departureAirport != null\r\n      @departureAirport = new (L.MapNode)(flight.departureAirport, @map)\r\n    if flight.arrivalAirport != null\r\n      @arrivalAirport = new (L.MapNode)(flight.arrivalAirport, @map)\r\n    if flight.Miles != null\r\n      @miles = flight.Miles\r\n    if flight['Orig WAC']\r\n      @origWAC = flight['Orig WAC']\r\n    if flight.totalSeats != null\r\n      @totalSeats = flight.totalSeats\r\n    if flight['Seats/Week'] != null\r\n      @seats_week = flight['Seats/Week']\r\n    @setPopup()\r\n    return\r\n  initialize: (flight, map) ->\r\n    @map = map\r\n    @visible = true\r\n    @id = flight['_id']\r\n    if flight.departureAirport != null\r\n      @departureAirport = new (L.MapNode)(flight.departureAirport, @map)\r\n    if flight.arrivalAirport != null\r\n      @arrivalAirport = new (L.MapNode)(flight.arrivalAirport, @map)\r\n    @miles = flight.Miles\r\n    @origWAC = flight['Orig WAC']\r\n    @totalSeats = flight.totalSeats\r\n    @seats_week = flight['Seats/Week']\r\n    @stops = flight.Stops\r\n    @pointList = [\r\n      @departureAirport.latlng\r\n      @arrivalAirport.latlng\r\n    ]\r\n    L.MapPaths.addInitializedPath this\r\n    @drawPath()\r\n  midPoint: (points, ud) ->\r\n    latDif = undefined\r\n    midPoint = undefined\r\n    midPoint = []\r\n    latDif = Math.abs(points[0].lat - (points[1].lat))\r\n    if points[0].lat > points[1].lat\r\n      if ud\r\n        midPoint[0] = points[1].lat + latDif / 4\r\n      else\r\n        midPoint[0] = points[0].lat - (latDif / 4)\r\n    else\r\n      if ud\r\n        midPoint[0] = points[1].lat + latDif / 4\r\n      else\r\n        midPoint[0] = points[1].lat - (latDif / 4)\r\n    midPoint[1] = (points[0].lng + points[1].lng) / 2\r\n    midPoint\r\n  calculateArch: ->\r\n    curved = undefined\r\n    line = undefined\r\n    line = 'geometry': 'coordinates': [\r\n      [\r\n        @departureAirport.latlng.lat\r\n        @departureAirport.latlng.lng\r\n      ]\r\n      @midPoint([\r\n        @departureAirport.latlng\r\n        @arrivalAirport.latlng\r\n      ], true)\r\n      [\r\n        @arrivalAirport.latlng.lat\r\n        @arrivalAirport.latlng.lng\r\n      ]\r\n    ]\r\n    curved = turf.bezier(line, 10000, 1)\r\n    @pointList = curved.geometry.coordinates\r\n    @pointList.push @arrivalAirport.latlng\r\n  refresh: ->\r\n    @setPopup()\r\n    @hide()\r\n    @drawPath()\r\n    @show()\r\n  setPopup: ->\r\n    div = undefined\r\n    popup = undefined\r\n    popup = new (L.popup)\r\n    div = L.DomUtil.create('div', '')\r\n    Blaze.renderWithData Template.pathDetails, this, div\r\n    popup.setContent div\r\n    @pathLine.bindPopup popup\r\n  setStyle: (color, weight) ->\r\n    @color = color\r\n    @weight = weight\r\n  drawPath: ->\r\n    archPos = undefined\r\n    i = undefined\r\n    len = undefined\r\n    mapPath = undefined\r\n    ref = undefined\r\n    @visible = true\r\n    archPos = []\r\n    ref = L.MapPaths.mapPaths\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      mapPath = ref[i]\r\n      if mapPath != this\r\n        if mapPath.departureAirport.equals(@departureAirport) and mapPath.arrivalAirport.equals(@arrivalAirport)\r\n          archPos[mapPath.archPosition] = true\r\n      i++\r\n    @calculateArch archPos\r\n    @pathLine = new (L.Polyline)(@pointList,\r\n      color: @color\r\n      weight: @weight\r\n      opacity: 0.8\r\n      smoothFactor: 1)\r\n    @pathLineDecorator = L.polylineDecorator(@pathLine, patterns: [ {\r\n      offset: '50px'\r\n      repeat: '100px'\r\n      symbol: new (L.Symbol.ArrowHead)(\r\n        pixelSize: 20\r\n        pathOptions: color: @color)\r\n    } ])\r\n    @setPopup()\r\n)\r\n\r\nL.mapPath = (flight, map) ->\r\n  new (L.MapPath)(flight, map)\r\n\r\nL.MapPaths =\r\n  mapPaths: []\r\n  factors: []\r\n  getLayerGroup: ->\r\n    L.layerGroup @mapPaths\r\n  getFactorById: (id) ->\r\n    factor = undefined\r\n    i = undefined\r\n    len = undefined\r\n    ref = undefined\r\n    ref = @factors\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      factor = ref[i]\r\n      if factor._id == id\r\n        return factor\r\n      i++\r\n    false\r\n  getMapPathByFactor: (factor) ->\r\n    i = undefined\r\n    len = undefined\r\n    ref = undefined\r\n    tempMapPath = undefined\r\n    ref = @mapPaths\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      tempMapPath = ref[i]\r\n      if tempMapPath.departureAirport.id == factor['departureAirport']._id and tempMapPath.arrivalAirport.id == factor['arrivalAirport']._id\r\n        return tempMapPath\r\n      i++\r\n    false\r\n  addInitializedPath: (mapPath) ->\r\n    @mapPaths.push mapPath\r\n  addFactor: (id, factor, map) ->\r\n    existingFactor = undefined\r\n    path = undefined\r\n    existingFactor = @getFactorById(id)\r\n    if existingFactor != false\r\n      return @getMapPathByFactor(existingFactor)\r\n    factor._id = id\r\n    path = @getMapPathByFactor(factor)\r\n    if path != false\r\n      path.totalSeats += factor['totalSeats']\r\n    else if path == false\r\n      path = new (L.MapPath)(factor, map).addTo(map)\r\n      path.totalSeats = factor['totalSeats']\r\n    @factors.push factor\r\n    path.flights++\r\n    path.refresh()\r\n    path\r\n  removeFactor: (id) ->\r\n    d1 = undefined\r\n    d2 = undefined\r\n    factor = undefined\r\n    i = undefined\r\n    len = undefined\r\n    o1 = undefined\r\n    o2 = undefined\r\n    path = undefined\r\n    ref = undefined\r\n    removeDest = undefined\r\n    removeOrig = undefined\r\n    tempMapPath = undefined\r\n    factor = @getFactorById(id)\r\n    if factor == false\r\n      return false\r\n    @factors.splice @factors.indexOf(factor), 1\r\n    path = @getMapPathByFactor(factor)\r\n    path.totalSeats -= factor['totalSeats']\r\n    path.flights--\r\n    if path.flights is 0\r\n      path.arrivalAirport.hide()\r\n      path.departureAirport.hide()\r\n      path.hide()\r\n      return false\r\n    else\r\n      path.show()\r\n      {\r\n        'path': path\r\n        'factor': factor\r\n      }\r\n  updatePath: (id, mapPath, map) ->\r\n    i = undefined\r\n    len = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    tempMapPath = undefined\r\n    ref = @mapPaths\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      tempMapPath = ref[i]\r\n      if tempMapPath.id == id\r\n        tempMapPath.hide()\r\n        tempMapPath.update mapPath\r\n        results.push tempMapPath.show()\r\n      else\r\n        results.push undefined\r\n      i++\r\n    results\r\n  showPath: (mapPath) ->\r\n    mapPath.show()\r\n  hidePath: (mapPath) ->\r\n    mapPath.hide()\r\n  hideAllPaths: ->\r\n    i = undefined\r\n    len = undefined\r\n    path = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    ref = @mapPaths\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      path = ref[i]\r\n      results.push path.hide()\r\n      i++\r\n    results\r\n  showAllPaths: ->\r\n    i = undefined\r\n    len = undefined\r\n    path = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    ref = @mapPaths\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      path = ref[i]\r\n      results.push path.show()\r\n      i++\r\n    results\r\n  hideAllNodes: ->\r\n    i = undefined\r\n    len = undefined\r\n    node = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    ref = L.MapNodes.mapNodes\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      node = ref[i]\r\n      results.push node.hide()\r\n      i++\r\n    results\r\n  showAllNodes: ->\r\n    L.MapNodes.showAllNodes()\r\n  hideBetween: (mapNodeA, mapNodeB) ->\r\n    i = undefined\r\n    len = undefined\r\n    mapPath = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    ref = @mapPaths\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      mapPath = ref[i]\r\n      if mapPath.departureAirport == mapNodeA and mapPath.arrivalAirport == mapNodeB\r\n        mapPath.hide()\r\n      if mapPath.departureAirport == mapNodeB and mapPath.arrivalAirport == mapNodeA\r\n        results.push mapPath.hide()\r\n      else\r\n        results.push undefined\r\n      i++\r\n    results\r\nL.MapNode = L.Path.extend(\r\n  visible: false\r\n  latlng: null\r\n  city: null\r\n  state: null\r\n  stateName: null\r\n  country: null\r\n  countryName: null\r\n  globalRegion: null\r\n  WAC: null\r\n  notes: null\r\n  code: null\r\n  name: null\r\n  key: null\r\n  map: null\r\n  marker: null\r\n  onAdd: (map) ->\r\n    if @marker != null\r\n      @marker.addTo map\r\n    return\r\n  onRemove: (map) ->\r\n    map.removeLayer @marker\r\n    return\r\n  setPopup: ->\r\n    div = undefined\r\n    popup = undefined\r\n    popup = new (L.popup)\r\n    div = L.DomUtil.create('div', '')\r\n    Blaze.renderWithData Template.nodeDetails, this, div\r\n    popup.setContent div\r\n    @marker.bindPopup popup\r\n  initialize: (node, map) ->\r\n    i = undefined\r\n    len = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    @map = map\r\n    @id = node['_id']\r\n    @name = node.name\r\n    @city = node.city\r\n    @state = node.state\r\n    @stateName = node.stateName\r\n    @country = node.country\r\n    @countryName = node.countryName\r\n    @globalRegion = node.globalRegion\r\n    @notes = node.notes\r\n    @WAC = node.WAC\r\n    @key = node.key\r\n    @latlng = new (L.LatLng)(node.loc.coordinates[1], node.loc.coordinates[0])\r\n    if !L.MapNodes.contains(this)\r\n      @marker = L.marker(@latlng)\r\n      @marker.on 'click', (e) ->\r\n        Template.map.nodeEvent L.MapNodes.getNodeByMarker(e.target._leaflet_id)\r\n      L.MapNodes.addInitializedNode this\r\n      @setPopup()\r\n    else\r\n      ref = L.MapNodes.mapNodes\r\n      results = []\r\n      i = 0\r\n      len = ref.length\r\n      while i < len\r\n        node = ref[i]\r\n        if node.id == @id\r\n          results.push @marker = node.marker\r\n        else\r\n          results.push undefined\r\n        i++\r\n      results\r\n  equals: (otherNode) ->\r\n    otherNode.latlng.lat == @latlng.lat and otherNode.latlng.lng == @latlng.lng\r\n  hide: ->\r\n    @visible = false\r\n    @map.removeLayer @marker\r\n  show: ->\r\n    @visible = true\r\n    @marker = L.marker(@latlng)\r\n    @setPopup()\r\n)\r\nL.MapNodes =\r\n  selectedNode: null\r\n  mapNodes: []\r\n  getNodeByMarker: (markerId) ->\r\n    for node in @mapNodes\r\n      if node.marker._leaflet_id is markerId\r\n        return node\r\n    return false\r\n  getLayerGroup: ->\r\n    L.layerGroup @mapNodes\r\n  addInitializedNode: (node) ->\r\n    @mapNodes.push node\r\n  nodeClickEvent: (node) ->\r\n    alert node.id\r\n  addNode: (mapNode) ->\r\n    exists = undefined\r\n    i = undefined\r\n    len = undefined\r\n    ref = undefined\r\n    tempMapNode = undefined\r\n    exists = false\r\n    ref = @mapNodes\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      tempMapNode = ref[i]\r\n      if tempMapNode.key == mapNode['_id']\r\n        exists = true\r\n      i++\r\n    if !exists\r\n      return new (L.MapNode)(mapNode, @map)\r\n    return\r\n  removeNode: (id) ->\r\n    i = undefined\r\n    len = undefined\r\n    ref = undefined\r\n    tempMapNode = undefined\r\n    ref = @mapNodes\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      tempMapNode = ref[i]\r\n      if tempMapNode.id == id\r\n        tempMapNode.hide()\r\n        @mapNodes.splice @mapNodes.indexOf(tempMapNode), 1\r\n        return\r\n      i++\r\n    return\r\n  updateNode: (mapNode) ->\r\n    i = undefined\r\n    len = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    tempMapNode = undefined\r\n    ref = @mapNodes\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      tempMapNode = ref[i]\r\n      if tempMapNode.id == tempMapNode['_id']\r\n        tempMapNode.hide()\r\n        tempMapNode.initialize mapNode, @map\r\n        results.push tempMapNode.show()\r\n      else\r\n        results.push undefined\r\n      i++\r\n    results\r\n  contains: (node) ->\r\n    i = undefined\r\n    len = undefined\r\n    mapNode = undefined\r\n    mapNodesContains = undefined\r\n    ref = undefined\r\n    mapNodesContains = false\r\n    ref = @mapNodes\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      mapNode = ref[i]\r\n      if mapNode.id == node.id\r\n        mapNodesContains = true\r\n      i++\r\n    mapNodesContains\r\n  mapNodeCount: ->\r\n    @mapNodes.length\r\n  hideNode: (node) ->\r\n    node.hide()\r\n  showNode: (node) ->\r\n    node.show()\r\n  hideAllNodes: ->\r\n    i = undefined\r\n    len = undefined\r\n    node = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    ref = @mapNodes\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      node = ref[i]\r\n      results.push node.hide()\r\n      i++\r\n    results\r\n  showAllNodes: ->\r\n    i = undefined\r\n    len = undefined\r\n    node = undefined\r\n    ref = undefined\r\n    results = undefined\r\n    ref = @mapNodes\r\n    results = []\r\n    i = 0\r\n    len = ref.length\r\n    while i < len\r\n      node = ref[i]\r\n      results.push node.show()\r\n      i++\r\n    results\r\n\r\nL.mapNode = (node, map) ->\r\n  new (L.MapNode)(node, map)\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/grits-net-mapper.coffee\n **/","\r\nL.LineUtil.PolylineDecorator = {\r\n    computeAngle: function(a, b) {\r\n        return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI) + 90;\r\n    },\r\n\r\n    getPointPathPixelLength: function(pts) {\r\n        var nbPts = pts.length;\r\n        if(nbPts < 2) {\r\n            return 0;\r\n        }\r\n        var dist = 0,\r\n            prevPt = pts[0],\r\n            pt;\r\n        for(var i=1; i<nbPts; i++) {\r\n            dist += prevPt.distanceTo(pt = pts[i]);\r\n            prevPt = pt;\r\n        } \r\n        return dist;\r\n    },\r\n\r\n    getPixelLength: function(pl, map) {\r\n        var ll = (pl instanceof L.Polyline) ? pl.getLatLngs() : pl,\r\n            nbPts = ll.length;\r\n        if(nbPts < 2) {\r\n            return 0;\r\n        }\r\n        var dist = 0,\r\n            prevPt = map.project(ll[0]), pt; \r\n        for(var i=1; i<nbPts; i++) {\r\n            dist += prevPt.distanceTo(pt = map.project(ll[i]));\r\n            prevPt = pt;\r\n        } \r\n        return dist;\r\n    },\r\n\r\n    /**\r\n    * path: array of L.LatLng\r\n    * offsetRatio: the ratio of the total pixel length where the pattern will start\r\n    * endOffsetRatio: the ratio of the total pixel length where the pattern will end\r\n    * repeatRatio: the ratio of the total pixel length between two points of the pattern \r\n    * map: the map, to access the current projection state\r\n    */\r\n    projectPatternOnPath: function (path, offsetRatio, endOffsetRatio, repeatRatio, map) {\r\n        var pathAsPoints = [], i;\r\n\r\n        for(i=0, l=path.length; i<l; i++) {\r\n            pathAsPoints[i] = map.project(path[i]);\r\n        }\r\n        // project the pattern as pixel points\r\n        var pattern = this.projectPatternOnPointPath(pathAsPoints, offsetRatio, endOffsetRatio, repeatRatio);\r\n        // and convert it to latlngs;\r\n        for(i=0, l=pattern.length; i<l; i++) {\r\n            pattern[i].latLng = map.unproject(pattern[i].pt);\r\n        }        \r\n        return pattern;\r\n    },\r\n    \r\n    projectPatternOnPointPath: function (pts, offsetRatio, endOffsetRatio, repeatRatio) {\r\n        var positions = [];\r\n        // 1. compute the absolute interval length in pixels\r\n        var repeatIntervalLength = this.getPointPathPixelLength(pts) * repeatRatio;\r\n        // 2. find the starting point by using the offsetRatio and find the last pixel using endOffsetRatio\r\n        var previous = this.interpolateOnPointPath(pts, offsetRatio);\r\n        var endOffsetPixels = endOffsetRatio > 0 ? this.getPointPathPixelLength(pts) * endOffsetRatio : 0;\r\n        \r\n        positions.push(previous);\r\n        if(repeatRatio > 0) {\r\n            // 3. consider only the rest of the path, starting at the previous point\r\n            var remainingPath = pts;\r\n            remainingPath = remainingPath.slice(previous.predecessor);\r\n            \r\n            remainingPath[0] = previous.pt;\r\n            var remainingLength = this.getPointPathPixelLength(remainingPath);\r\n            \r\n            // 4. project as a ratio of the remaining length,\r\n            // and repeat while there is room for another point of the pattern\r\n\r\n            while(repeatIntervalLength <= remainingLength-endOffsetPixels) {\r\n                previous = this.interpolateOnPointPath(remainingPath, repeatIntervalLength/remainingLength);\r\n                positions.push(previous);\r\n                remainingPath = remainingPath.slice(previous.predecessor);\r\n                remainingPath[0] = previous.pt;\r\n                remainingLength = this.getPointPathPixelLength(remainingPath);\r\n            }\r\n        }\r\n        return positions;\r\n    },\r\n\r\n    /**\r\n    * pts: array of L.Point\r\n    * ratio: the ratio of the total length where the point should be computed\r\n    * Returns null if ll has less than 2 LatLng, or an object with the following properties:\r\n    *    latLng: the LatLng of the interpolated point\r\n    *    predecessor: the index of the previous vertex on the path\r\n    *    heading: the heading of the path at this point, in degrees\r\n    */\r\n    interpolateOnPointPath: function (pts, ratio) {\r\n        var nbVertices = pts.length;\r\n\r\n        if (nbVertices < 2) {\r\n            return null;\r\n        }\r\n        // easy limit cases: ratio negative/zero => first vertex\r\n        if (ratio <= 0) {\r\n            return {\r\n                pt: pts[0],\r\n                predecessor: 0,\r\n                heading: this.computeAngle(pts[0], pts[1])\r\n            };\r\n        }\r\n        // ratio >=1 => last vertex\r\n        if (ratio >= 1) {\r\n            return {\r\n                pt: pts[nbVertices - 1],\r\n                predecessor: nbVertices - 1,\r\n                heading: this.computeAngle(pts[nbVertices - 2], pts[nbVertices - 1])\r\n            };\r\n        }\r\n        // 1-segment-only path => direct linear interpolation\r\n        if (nbVertices == 2) {\r\n            return {\r\n                pt: this.interpolateBetweenPoints(pts[0], pts[1], ratio),\r\n                predecessor: 0,\r\n                heading: this.computeAngle(pts[0], pts[1])\r\n            };\r\n        }\r\n            \r\n        var pathLength = this.getPointPathPixelLength(pts);\r\n        var a = pts[0], b = a,\r\n            ratioA = 0, ratioB = 0,\r\n            distB = 0;\r\n        // follow the path segments until we find the one\r\n        // on which the point must lie => [ab] \r\n        var i = 1;\r\n        for (; i < nbVertices && ratioB < ratio; i++) {\r\n            a = b;\r\n            ratioA = ratioB;\r\n            b = pts[i];\r\n            distB += a.distanceTo(b);\r\n            ratioB = distB / pathLength;\r\n        }\r\n\r\n        // compute the ratio relative to the segment [ab]\r\n        var segmentRatio = (ratio - ratioA) / (ratioB - ratioA);\r\n\r\n        return {\r\n            pt: this.interpolateBetweenPoints(a, b, segmentRatio),\r\n            predecessor: i-2,\r\n            heading: this.computeAngle(a, b)\r\n        };\r\n    },\r\n    \r\n    /**\r\n    * Finds the point which lies on the segment defined by points A and B,\r\n    * at the given ratio of the distance from A to B, by linear interpolation. \r\n    */\r\n    interpolateBetweenPoints: function (ptA, ptB, ratio) {\r\n        if(ptB.x != ptA.x) {\r\n            return new L.Point(\r\n                (ptA.x * (1 - ratio)) + (ratio * ptB.x),\r\n                (ptA.y * (1 - ratio)) + (ratio * ptB.y)\r\n            );\r\n        }\r\n        // special case where points lie on the same vertical axis\r\n        return new L.Point(ptA.x, ptA.y + (ptB.y - ptA.y) * ratio);\r\n    }\r\n};\n\r\nL.PolylineDecorator = L.LayerGroup.extend({\r\n    options: {\r\n        patterns: []\r\n    },\r\n\r\n    initialize: function(paths, options) {\r\n        L.LayerGroup.prototype.initialize.call(this);\r\n        L.Util.setOptions(this, options);\r\n        this._map = null;\r\n        this._initPaths(paths);\r\n        this._initPatterns();\r\n    },\r\n\r\n    /**\r\n    * Deals with all the different cases. p can be one of these types:\r\n    * array of LatLng, array of 2-number arrays, Polyline, Polygon,\r\n    * array of one of the previous.\r\n    */\r\n    _initPaths: function(p) {\r\n        this._paths = [];\r\n        var isPolygon = false;\r\n        if(p instanceof L.Polyline) {\r\n            this._initPath(p.getLatLngs(), (p instanceof L.Polygon));\r\n        } else if(L.Util.isArray(p) && p.length > 0) {\r\n            if(p[0] instanceof L.Polyline) {\r\n                for(var i=0; i<p.length; i++) {\r\n                    this._initPath(p[i].getLatLngs(), (p[i] instanceof L.Polygon));\r\n                }\r\n            } else {\r\n                this._initPath(p);\r\n            }\r\n        }\r\n    },\r\n\r\n    _isCoordArray: function(ll) {\r\n        return(L.Util.isArray(ll) && ll.length > 0 && (\r\n            ll[0] instanceof L.LatLng ||\r\n            (L.Util.isArray(ll[0]) && ll[0].length == 2 && typeof ll[0][0] === 'number')\r\n        ));\r\n    },\r\n\r\n    _initPath: function(path, isPolygon) {\r\n        var latLngs;\r\n        // It may still be an array of array of coordinates\r\n        // (ex: polygon with rings)\r\n        if(this._isCoordArray(path)) {\r\n            latLngs = [path];\r\n        } else {\r\n            latLngs = path;\r\n        }\r\n        for(var i=0; i<latLngs.length; i++) {\r\n            // As of Leaflet >= v0.6, last polygon vertex (=first) isn't repeated.\r\n            // Our algorithm needs it, so we add it back explicitly.\r\n            if(isPolygon) {\r\n                latLngs[i].push(latLngs[i][0]);\r\n            }\r\n            this._paths.push(latLngs[i]);\r\n        }\r\n    },\r\n\r\n    _initPatterns: function() {\r\n        this._isZoomDependant = false;\r\n        this._patterns = [];\r\n        var pattern;\r\n        // parse pattern definitions and precompute some values\r\n        for(var i=0;i<this.options.patterns.length;i++) {\r\n            pattern = this._parsePatternDef(this.options.patterns[i]);\r\n            this._patterns.push(pattern);\r\n            // determines if we have to recompute the pattern on each zoom change\r\n            this._isZoomDependant = this._isZoomDependant ||\r\n                pattern.isOffsetInPixels ||\r\n                pattern.isEndOffsetInPixels ||\r\n                pattern.isRepeatInPixels ||\r\n                pattern.symbolFactory.isZoomDependant;\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Changes the patterns used by this decorator\r\n    * and redraws the new one.\r\n    */\r\n    setPatterns: function(patterns) {\r\n        this.options.patterns = patterns;\r\n        this._initPatterns();\r\n        this._softRedraw();\r\n    },\r\n\r\n    /**\r\n    * Changes the patterns used by this decorator\r\n    * and redraws the new one.\r\n    */\r\n    setPaths: function(paths) {\r\n        this._initPaths(paths);\r\n        this.redraw();\r\n    },\r\n\r\n    /**\r\n    * Parse the pattern definition\r\n    */\r\n    _parsePatternDef: function(patternDef, latLngs) {\r\n        var pattern = {\r\n            cache: [],\r\n            symbolFactory: patternDef.symbol,\r\n            isOffsetInPixels: false,\r\n            isEndOffsetInPixels: false,\r\n            isRepeatInPixels: false\r\n        };\r\n\r\n        // Parse offset and repeat values, managing the two cases:\r\n        // absolute (in pixels) or relative (in percentage of the polyline length)\r\n        if(typeof patternDef.offset === 'string' && patternDef.offset.indexOf('%') != -1) {\r\n            pattern.offset = parseFloat(patternDef.offset) / 100;\r\n        } else {\r\n            pattern.offset = patternDef.offset ? parseFloat(patternDef.offset) : 0;\r\n            pattern.isOffsetInPixels = (pattern.offset > 0);\r\n        }\r\n\r\n        if(typeof patternDef.endOffset === 'string' && patternDef.endOffset.indexOf('%') != -1) {\r\n            pattern.endOffset = parseFloat(patternDef.endOffset) / 100;\r\n        } else {\r\n            pattern.endOffset = patternDef.endOffset ? parseFloat(patternDef.endOffset) : 0;\r\n            pattern.isEndOffsetInPixels = (pattern.endOffset > 0);\r\n        }\r\n\r\n        if(typeof patternDef.repeat === 'string' && patternDef.repeat.indexOf('%') != -1) {\r\n            pattern.repeat = parseFloat(patternDef.repeat) / 100;\r\n        } else {\r\n            pattern.repeat = parseFloat(patternDef.repeat);\r\n            pattern.isRepeatInPixels = (pattern.repeat > 0);\r\n        }\r\n\r\n        // TODO: 0 => not pixel dependant => 0%\r\n\r\n        return(pattern);\r\n    },\r\n\r\n    onAdd: function (map) {\r\n        this._map = map;\r\n        this._draw();\r\n        // listen to zoom changes to redraw pixel-spaced patterns\r\n        if(this._isZoomDependant) {\r\n            this._map.on('zoomend', this._softRedraw, this);\r\n        }\r\n    },\r\n\r\n    onRemove: function (map) {\r\n        // remove optional map zoom listener\r\n        this._map.off('zoomend', this._softRedraw, this);\r\n        this._map = null;\r\n        L.LayerGroup.prototype.onRemove.call(this, map);\r\n    },\r\n\r\n    /**\r\n    * Returns an array of ILayers object\r\n    */\r\n    _buildSymbols: function(latLngs, symbolFactory, directionPoints) {\r\n        var symbols = [];\r\n        for(var i=0, l=directionPoints.length; i<l; i++) {\r\n            symbols.push(symbolFactory.buildSymbol(directionPoints[i], latLngs, this._map, i, l));\r\n        }\r\n        return symbols;\r\n    },\r\n\r\n    _getCache: function(pattern, zoom, pathIndex) {\r\n        var zoomCache = pattern.cache[zoom];\r\n        if(typeof zoomCache === 'undefined') {\r\n            pattern.cache[zoom] = [];\r\n            return null;\r\n        }\r\n        return zoomCache[pathIndex];\r\n    },\r\n\r\n    /**\r\n    * Select pairs of LatLng and heading angle,\r\n    * that define positions and directions of the symbols\r\n    * on the path\r\n    */\r\n    _getDirectionPoints: function(pathIndex, pattern) {\r\n        var zoom = this._map.getZoom();\r\n        var dirPoints = this._getCache(pattern, zoom, pathIndex);\r\n        if(dirPoints) {\r\n            return dirPoints;\r\n        }\r\n\r\n        var offset, endOffset, repeat, pathPixelLength = null, latLngs = this._paths[pathIndex];\r\n        if(pattern.isOffsetInPixels) {\r\n            pathPixelLength =  L.LineUtil.PolylineDecorator.getPixelLength(latLngs, this._map);\r\n            offset = pattern.offset/pathPixelLength;\r\n        } else {\r\n            offset = pattern.offset;\r\n        }\r\n        if(pattern.isEndOffsetInPixels) {\r\n            pathPixelLength = (pathPixelLength !== null) ? pathPixelLength : L.LineUtil.PolylineDecorator.getPixelLength(latLngs, this._map);\r\n            endOffset = pattern.endOffset/pathPixelLength;\r\n        } else {\r\n            endOffset = pattern.endOffset;\r\n        }\r\n        if(pattern.isRepeatInPixels) {\r\n            pathPixelLength = (pathPixelLength !== null) ? pathPixelLength : L.LineUtil.PolylineDecorator.getPixelLength(latLngs, this._map);\r\n            repeat = pattern.repeat/pathPixelLength;\r\n        } else {\r\n            repeat = pattern.repeat;\r\n        }\r\n        dirPoints = L.LineUtil.PolylineDecorator.projectPatternOnPath(latLngs, offset, endOffset, repeat, this._map);\r\n        // save in cache to avoid recomputing this\r\n        pattern.cache[zoom][pathIndex] = dirPoints;\r\n\r\n        return dirPoints;\r\n    },\r\n\r\n    /**\r\n    * Public redraw, invalidating the cache.\r\n    */\r\n    redraw: function() {\r\n        this._redraw(true);\r\n    },\r\n\r\n    /**\r\n    * \"Soft\" redraw, called internally for example on zoom changes,\r\n    * keeping the cache.\r\n    */\r\n    _softRedraw: function() {\r\n        this._redraw(false);\r\n    },\r\n\r\n    _redraw: function(clearCache) {\r\n        if(this._map === null)\r\n            return;\r\n        this.clearLayers();\r\n        if(clearCache) {\r\n            for(var i=0; i<this._patterns.length; i++) {\r\n                this._patterns[i].cache = [];\r\n            }\r\n        }\r\n        this._draw();\r\n    },\r\n\r\n    /**\r\n    * Draw a single pattern\r\n    */\r\n    _drawPattern: function(pattern) {\r\n        var directionPoints, symbols;\r\n        for(var i=0; i < this._paths.length; i++) {\r\n            directionPoints = this._getDirectionPoints(i, pattern);\r\n            symbols = this._buildSymbols(this._paths[i], pattern.symbolFactory, directionPoints);\r\n            for(var j=0; j < symbols.length; j++) {\r\n                this.addLayer(symbols[j]);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Draw all patterns\r\n    */\r\n    _draw: function () {\r\n        for(var i=0; i<this._patterns.length; i++) {\r\n            this._drawPattern(this._patterns[i]);\r\n        }\r\n    }\r\n});\r\n/*\r\n * Allows compact syntax to be used\r\n */\r\nL.polylineDecorator = function (paths, options) {\r\n    return new L.PolylineDecorator(paths, options);\r\n};\r\n\nL.RotatedMarker = L.Marker.extend({\r\n    options: {\r\n        angle: 0\r\n    },\r\n\r\n    _setPos: function (pos) {\r\n        L.Marker.prototype._setPos.call(this, pos);\r\n        \r\n        if (L.DomUtil.TRANSFORM) {\r\n            // use the CSS transform rule if available\r\n            this._icon.style[L.DomUtil.TRANSFORM] += ' rotate(' + this.options.angle + 'deg)';\r\n        } else if(L.Browser.ie) {\r\n            // fallback for IE6, IE7, IE8\r\n            var rad = this.options.angle * (Math.PI / 180),\r\n                costheta = Math.cos(rad),\r\n                sintheta = Math.sin(rad);\r\n            this._icon.style.filter += ' progid:DXImageTransform.Microsoft.Matrix(sizingMethod=\\'auto expand\\', M11=' + \r\n                costheta + ', M12=' + (-sintheta) + ', M21=' + sintheta + ', M22=' + costheta + ')';                \r\n        }\r\n    },\r\n    setAngle: function (ang) {\r\n        this.options.angle = ang;\r\n    }\r\n});\r\n\r\nL.rotatedMarker = function (pos, options) {\r\n    return new L.RotatedMarker(pos, options);\r\n};\r\n\n/**\r\n* Defines several classes of symbol factories,\r\n* to be used with L.PolylineDecorator\r\n*/\r\n\r\nL.Symbol = L.Symbol || {};\r\n\r\n/**\r\n* A simple dash symbol, drawn as a Polyline.\r\n* Can also be used for dots, if 'pixelSize' option is given the 0 value.\r\n*/\r\nL.Symbol.Dash = L.Class.extend({\r\n    isZoomDependant: true,\r\n    \r\n    options: {\r\n        pixelSize: 10,\r\n        pathOptions: { }\r\n    },\r\n    \r\n    initialize: function (options) {\r\n        L.Util.setOptions(this, options);\r\n        this.options.pathOptions.clickable = false;\r\n    },\r\n\r\n    buildSymbol: function(dirPoint, latLngs, map, index, total) {\r\n        var opts = this.options,\r\n            d2r = Math.PI / 180;\r\n        \r\n        // for a dot, nothing more to compute\r\n        if(opts.pixelSize <= 1) {\r\n            return new L.Polyline([dirPoint.latLng, dirPoint.latLng], opts.pathOptions);\r\n        }\r\n        \r\n        var midPoint = map.project(dirPoint.latLng);\r\n        var angle = (-(dirPoint.heading - 90)) * d2r;\r\n        var a = new L.Point(\r\n                midPoint.x + opts.pixelSize * Math.cos(angle + Math.PI) / 2,\r\n                midPoint.y + opts.pixelSize * Math.sin(angle) / 2\r\n            );\r\n        // compute second point by central symmetry to avoid unecessary cos/sin\r\n        var b = midPoint.add(midPoint.subtract(a));\r\n        return new L.Polyline([map.unproject(a), map.unproject(b)], opts.pathOptions);\r\n    }\r\n});\r\n\r\nL.Symbol.dash = function (options) {\r\n    return new L.Symbol.Dash(options);\r\n};\r\n\r\nL.Symbol.ArrowHead = L.Class.extend({\r\n    isZoomDependant: true,\r\n    \r\n    options: {\r\n        polygon: true,\r\n        pixelSize: 10,\r\n        headAngle: 60,\r\n        pathOptions: {\r\n            stroke: false,\r\n            weight: 2\r\n        }\r\n    },\r\n    \r\n    initialize: function (options) {\r\n        L.Util.setOptions(this, options);\r\n        this.options.pathOptions.clickable = false;\r\n    },\r\n\r\n    buildSymbol: function(dirPoint, latLngs, map, index, total) {\r\n        var opts = this.options;\r\n        var path;\r\n        if(opts.polygon) {\r\n            path = new L.Polygon(this._buildArrowPath(dirPoint, map), opts.pathOptions);\r\n        } else {\r\n            path = new L.Polyline(this._buildArrowPath(dirPoint, map), opts.pathOptions);\r\n        }\r\n        return path;\r\n    },\r\n    \r\n    _buildArrowPath: function (dirPoint, map) {\r\n        var d2r = Math.PI / 180;\r\n        var tipPoint = map.project(dirPoint.latLng);\r\n        var direction = (-(dirPoint.heading - 90)) * d2r;\r\n        var radianArrowAngle = this.options.headAngle / 2 * d2r;\r\n        \r\n        var headAngle1 = direction + radianArrowAngle,\r\n            headAngle2 = direction - radianArrowAngle;\r\n        var arrowHead1 = new L.Point(\r\n                tipPoint.x - this.options.pixelSize * Math.cos(headAngle1),\r\n                tipPoint.y + this.options.pixelSize * Math.sin(headAngle1)),\r\n            arrowHead2 = new L.Point(\r\n                tipPoint.x - this.options.pixelSize * Math.cos(headAngle2),\r\n                tipPoint.y + this.options.pixelSize * Math.sin(headAngle2));\r\n\r\n        return [\r\n            map.unproject(arrowHead1),\r\n            dirPoint.latLng,\r\n            map.unproject(arrowHead2)\r\n        ];\r\n    }\r\n});\r\n\r\nL.Symbol.arrowHead = function (options) {\r\n    return new L.Symbol.ArrowHead(options);\r\n};\r\n\r\nL.Symbol.Marker = L.Class.extend({\r\n    isZoomDependant: false,\r\n\r\n    options: {\r\n        markerOptions: { },\r\n        rotate: false\r\n    },\r\n    \r\n    initialize: function (options) {\r\n        L.Util.setOptions(this, options);\r\n        this.options.markerOptions.clickable = false;\r\n        this.options.markerOptions.draggable = false;\r\n        this.isZoomDependant = (L.Browser.ie && this.options.rotate);\r\n    },\r\n\r\n    buildSymbol: function(directionPoint, latLngs, map, index, total) {\r\n        if(!this.options.rotate) {\r\n            return new L.Marker(directionPoint.latLng, this.options.markerOptions);\r\n        }\r\n        else {\r\n            this.options.markerOptions.angle = directionPoint.heading;\r\n            return new L.RotatedMarker(directionPoint.latLng, this.options.markerOptions);\r\n        }\r\n    }\r\n});\r\n\r\nL.Symbol.marker = function (options) {\r\n    return new L.Symbol.Marker(options);\r\n};\r\n\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/leaflet-polylinedecorator/leaflet.polylineDecorator.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}