// Generated by CoffeeScript 1.10.0
'use strict';
if (typeof L !== 'undefined') {
  L.MapPath = L.Path.extend({
    id: null,
    map: null,
    smoothFactor: 1.0,
    pointList: null,
    pathLine: null,
    origin: null,
    destination: null,
    destWAC: null,
    miles: null,
    origWAC: null,
    seats: null,
    seats_week: null,
    stops: null,
    flights: 0,
    visible: false,
    onAdd: function(map) {
      this.show();
    },
    show: function() {
      this.visible = true;
      if (this.pathLine !== null) {
        this.pathLine.addTo(this.map);
      }
      if (this.origin !== null) {
        this.origin.addTo(this.map);
      }
      if (this.destination !== null) {
        this.destination.addTo(this.map);
      }
    },
    hide: function() {
      this.visible = false;
      if (this.pathLine !== null) {
        this.map.removeLayer(this.pathLine);
      }
    },
    update: function(flight) {
      if (flight.origin != null) {
        this.origin = new L.MapNode(flight.Orig, this.map);
      }
      if (flight.Dest != null) {
        this.destination = new L.MapNode(flight.Dest, this.map);
      }
      if (flight.Miles != null) {
        this.miles = flight.Miles;
      }
      if (flight['Orig WAC']) {
        this.origWAC = flight['Orig WAC'];
      }
      if (flight.Seats != null) {
        this.seats = flight.Seats;
      }
      if (flight['Seats/Week'] != null) {
        this.seats_week = flight['Seats/Week'];
      }
      this.setPopup();
    },
    initialize: function(flight, map) {
      this.map = map;
      this.visible = true;
      this.id = flight['_id'];
      if (flight.Orig != null) {
        this.origin = new L.MapNode(flight.Orig, this.map);
      }
      if (flight.Dest != null) {
        this.destination = new L.MapNode(flight.Dest, this.map);
      }
      this.miles = flight.Miles;
      this.origWAC = flight['Orig WAC'];
      this.seats = flight.Seats;
      this.seats_week = flight['Seats/Week'];
      this.stops = flight.Stops;
      this.pointList = [this.origin.latlng, this.destination.latlng];
      L.MapPaths.addInitializedPath(this);
      return this.drawPath();
    },
    midPoint: function(points, ud) {
      var latDif, midPoint;
      midPoint = [];
      latDif = Math.abs(points[0].lat - points[1].lat);
      if (points[0].lat > points[1].lat) {
        if (ud) {
          midPoint[0] = points[1].lat + latDif / 4;
        } else {
          midPoint[0] = points[0].lat - latDif / 4;
        }
      } else {
        if (ud) {
          midPoint[0] = points[1].lat + latDif / 4;
        } else {
          midPoint[0] = points[1].lat - latDif / 4;
        }
      }
      midPoint[1] = (points[0].lng + points[1].lng) / 2;
      return midPoint;
    },
    calculateArch: function() {
      var curved, line;
      line = {
        'geometry': {
          'coordinates': [[this.origin.latlng.lat, this.origin.latlng.lng], this.midPoint([this.origin.latlng, this.destination.latlng], true), [this.destination.latlng.lat, this.destination.latlng.lng]]
        }
      };
      curved = turf.bezier(line, 10000, 1);
      return this.pointList = curved.geometry.coordinates;
    },
    refresh: function() {
      this.setPopup();
      this.hide();
      this.drawPath();
      return this.show();
    },
    setPopup: function() {
      var div, popup;
      popup = new L.popup();
      div = L.DomUtil.create("div", "");
      popup.setContent(div);
      return this.pathLine.bindPopup(popup);
    },
    setStyle: function() {
      var mid;
      mid = (100 - Math.floor(this.seats / 100)).toString();
      if (mid < 10) {
        mid = "0" + mid;
      }
      this.color = '#99' + mid + "00";
      return this.weight = this.seats / 250 + 2;
    },
    drawPath: function() {
      var archPos, i, len, mapPath, ref;
      this.setStyle();
      this.visible = true;
      archPos = [];
      ref = L.MapPaths.mapPaths;
      for (i = 0, len = ref.length; i < len; i++) {
        mapPath = ref[i];
        if (mapPath !== this) {
          if ((mapPath.origin.equals(this.origin)) && (mapPath.destination.equals(this.destination))) {
            archPos[mapPath.archPosition] = true;
          }
        }
      }
      this.calculateArch(archPos);
      this.pathLine = new L.Polyline(this.pointList, {
        color: this.color,
        weight: this.weight,
        opacity: 0.8,
        smoothFactor: 1
      });
      return this.setPopup();
    }
  });
  L.mapPath = function(flight, map) {
    return new L.MapPath(flight, map);
  };
  L.MapPaths = {
    mapPaths: [],
    factors: [],
    getLayerGroup: function() {
      return L.layerGroup(this.mapPaths);
    },
    getFactorById: function(id) {
      var factor, i, len, ref;
      ref = this.factors;
      for (i = 0, len = ref.length; i < len; i++) {
        factor = ref[i];
        if (factor._id === id) {
          return factor;
        }
      }
      return false;
    },
    getMapPathByFactor: function(factor) {
      var i, len, ref, tempMapPath;
      ref = this.mapPaths;
      for (i = 0, len = ref.length; i < len; i++) {
        tempMapPath = ref[i];
        if (tempMapPath.origin.id === factor["Orig"]._id && tempMapPath.destination.id === factor["Dest"]._id) {
          return tempMapPath;
        }
      }
      return false;
    },
    addInitializedPath: function(mapPath) {
      return this.mapPaths.push(mapPath);
    },
    addFactor: function(id, factor, map) {
      var currentPath, exists, path;
      if (this.getFactorById(id) === false) {
        return;
      }
      factor._id = id;
      exists = false;
      path = this.getMapPathByFactor(factor);
      if (path !== false) {
        path.seats += factor["Seats"];
        path.flights++;
        path.refresh();
        this.factors.push(factor);
      }
      if (path === false) {
        currentPath = new L.MapPath(factor, map).addTo(map);
        return this.factors.push(factor);
      }
    },
    removeFactor: function(id) {
      var d1, d2, i, j, len, len1, o1, o2, ref, ref1, removeDest, removeOrig, tempMapPath;
      ref = this.mapPaths;
      for (i = 0, len = ref.length; i < len; i++) {
        tempMapPath = ref[i];
        if ((tempMapPath != null) && tempMapPath.id === id) {
          tempMapPath.hide();
          removeDest = true;
          removeOrig = true;
          o1 = tempMapPath.origin;
          d1 = tempMapPath.destination;
          ref1 = this.mapPaths;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            tempMapPath = ref1[j];
            o2 = tempMapPath.origin;
            d2 = tempMapPath.destination;
            if ((o2.id === o1.id || o1.id === d2.id) && tempMapPath !== tempMapPath) {
              removeOrig = false;
            }
            if ((d2.id === d1.id || d1.id === o2.id) && tempMapPath !== tempMapPath) {
              removeDest = false;
            }
          }
          if (removeDest) {
            tempMapPath.destination.hide();
            L.MapNodes.mapNodes.splice(L.MapNodes.mapNodes.indexOf(tempMapPath.destination), 1);
          }
          if (removeOrig) {
            tempMapPath.origin.hide();
            L.MapNodes.mapNodes.splice(L.MapNodes.mapNodes.indexOf(tempMapPath.origin), 1);
          }
          this.mapPaths.splice(this.mapPaths.indexOf(tempMapPath), 1);
        }
      }
    },
    updatePath: function(id, mapPath, map) {
      var i, len, ref, results, tempMapPath;
      ref = this.mapPaths;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        tempMapPath = ref[i];
        if (tempMapPath.id === id) {
          tempMapPath.hide();
          tempMapPath.update(mapPath);
          results.push(tempMapPath.show());
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    showPath: function(mapPath) {
      return mapPath.show();
    },
    hidePath: function(mapPath) {
      return mapPath.hide();
    },
    hideAllPaths: function() {
      var i, len, path, ref, results;
      ref = this.mapPaths;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        path = ref[i];
        results.push(path.hide());
      }
      return results;
    },
    showAllPaths: function() {
      var i, len, path, ref, results;
      ref = this.mapPaths;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        path = ref[i];
        results.push(path.show());
      }
      return results;
    },
    hideAllNodes: function() {
      var i, len, node, ref, results;
      ref = L.MapNodes.mapNodes;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        results.push(node.hide());
      }
      return results;
    },
    showAllNodes: function() {
      return L.MapNodes.showAllNodes();
    },
    hideBetween: function(mapNodeA, mapNodeB) {
      var i, len, mapPath, ref, results;
      ref = this.mapPaths;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        mapPath = ref[i];
        if (mapPath.origin === mapNodeA && mapPath.destination === mapNodeB) {
          mapPath.hide();
        }
        if (mapPath.origin === mapNodeB && mapPath.destination === mapNodeA) {
          results.push(mapPath.hide());
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };
  L.MapNode = L.Path.extend({
    latlng: null,
    city: null,
    code: null,
    country: null,
    countryName: null,
    globalRegion: null,
    name: null,
    notes: null,
    state: null,
    stateName: null,
    wac: null,
    key: null,
    map: null,
    marker: null,
    onAdd: function(map) {
      if (this.marker !== null) {
        this.marker.addTo(map);
      }
    },
    onRemove: function(map) {
      map.removeLayer(this.marker);
    },
    setPopup: function() {
      var div, popup;
      popup = new L.popup();
      div = L.DomUtil.create("div", "");
      Blaze.renderWithData(Template.nodeDetails, this, div);
      popup.setContent(div);
      return this.marker.bindPopup(popup);
    },
    initialize: function(node, map) {
      var i, len, ref, results;
      this.map = map;
      this.visible = true;
      this.id = node['_id'];
      this.city = node.City;
      this.code = node.Code;
      this.country = node.Country;
      this.countryName = node['Country Name'];
      this.globalRegion = node['Global Region'];
      this.name = node.Name;
      this.notes = node.Notes;
      this.state = node.State;
      this.stateName = node['State Name'];
      this.wac = node.WAC;
      this.key = node.key;
      this.latlng = new L.LatLng(node.loc.coordinates[1], node.loc.coordinates[0]);
      if (!L.MapNodes.contains(this)) {
        this.marker = L.marker(this.latlng);
        L.MapNodes.addInitializedNode(this);
        return this.setPopup();
      } else {
        ref = L.MapNodes.mapNodes;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          node = ref[i];
          if (node.id === this.id) {
            results.push(this.marker = node.marker);
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    },
    equals: function(otherNode) {
      return (otherNode.latlng.lat === this.latlng.lat) && (otherNode.latlng.lng === this.latlng.lng);
    },
    hide: function() {
      this.visible = false;
      return this.map.removeLayer(this.marker);
    },
    show: function() {
      this.visible = true;
      this.marker = L.marker(this.latlng);
      return this.setPopup();
    }
  });
  L.MapNodes = {
    mapNodes: [],
    getLayerGroup: function() {
      return L.layerGroup(this.mapNodes);
    },
    addInitializedNode: function(node) {
      return this.mapNodes.push(node);
    },
    addNode: function(mapNode) {
      var exists, i, len, ref, tempMapNode;
      exists = false;
      ref = this.mapNodes;
      for (i = 0, len = ref.length; i < len; i++) {
        tempMapNode = ref[i];
        if (tempMapNode.key === mapNode["_id"]) {
          exists = true;
        }
      }
      if (!exists) {
        return new L.MapNode(mapNode, this.map);
      }
    },
    removeNode: function(id) {
      var i, len, ref, tempMapNode;
      ref = this.mapNodes;
      for (i = 0, len = ref.length; i < len; i++) {
        tempMapNode = ref[i];
        if (tempMapNode.id === id) {
          tempMapNode.hide();
          this.mapNodes.splice(this.mapNodes.indexOf(tempMapNode), 1);
          return;
        }
      }
    },
    updateNode: function(mapNode) {
      var i, len, ref, results, tempMapNode;
      ref = this.mapNodes;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        tempMapNode = ref[i];
        if (tempMapNode.id === tempMapNode["_id"]) {
          tempMapNode.hide();
          tempMapNode.initialize(mapNode, this.map);
          results.push(tempMapNode.show());
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    contains: function(node) {
      var i, len, mapNode, mapNodesContains, ref;
      mapNodesContains = false;
      ref = this.mapNodes;
      for (i = 0, len = ref.length; i < len; i++) {
        mapNode = ref[i];
        if (mapNode.id === node.id) {
          mapNodesContains = true;
        }
      }
      return mapNodesContains;
    },
    mapNodeCount: function() {
      return this.mapNodes.length;
    },
    hideNode: function(node) {
      return node.hide();
    },
    showNode: function(node) {
      return node.show();
    },
    hideAllNodes: function() {
      var i, len, node, ref, results;
      ref = this.mapNodes;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        results.push(node.hide());
      }
      return results;
    },
    showAllNodes: function() {
      var i, len, node, ref, results;
      ref = this.mapNodes;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        node = ref[i];
        results.push(node.show());
      }
      return results;
    }
  };
  L.mapNode = function(node, map) {
    return new L.MapNode(node, map);
  };
} else {
  console.log('Leaflet Object [L] is missing.');
}
