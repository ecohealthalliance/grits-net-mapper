// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  if (Meteor.isClient) {
    if (typeof L !== 'undefined') {
      L.MapPath = L.Path.extend({
        id: null,
        map: null,
        smoothFactor: 1.0,
        pointList: null,
        pathLine: null,
        origin: null,
        destination: null,
        destWAC: null,
        miles: null,
        origWAC: null,
        seats: null,
        seats_week: null,
        stops: null,
        flights: 0,
        visible: false,
        onAdd: function(map) {
          this.show();
        },
        show: function() {
          this.visible = true;
          if (this.pathLine !== null) {
            this.pathLine.addTo(this.map);
          }
          if (this.origin !== null && this.origin.visible === false) {
            this.origin.addTo(this.map);
          }
          if (this.destination !== null && this.destination.visible === false) {
            this.destination.addTo(this.map);
          }
        },
        hide: function() {
          this.visible = false;
          if (this.pathLine !== null) {
            this.map.removeLayer(this.pathLine);
          }
        },
        update: function(flight) {
          if (flight.origin != null) {
            this.origin = new L.MapNode(flight.Orig, this.map);
          }
          if (flight.Dest != null) {
            this.destination = new L.MapNode(flight.Dest, this.map);
          }
          if (flight.Miles != null) {
            this.miles = flight.Miles;
          }
          if (flight['Orig WAC']) {
            this.origWAC = flight['Orig WAC'];
          }
          if (flight.Seats != null) {
            this.seats = flight.Seats;
          }
          if (flight['Seats/Week'] != null) {
            this.seats_week = flight['Seats/Week'];
          }
          this.setPopup();
        },
        initialize: function(flight, map) {
          this.map = map;
          this.visible = true;
          this.id = flight['_id'];
          if (flight.Orig != null) {
            this.origin = new L.MapNode(flight.Orig, this.map);
          }
          if (flight.Dest != null) {
            this.destination = new L.MapNode(flight.Dest, this.map);
          }
          this.miles = flight.Miles;
          this.origWAC = flight['Orig WAC'];
          this.seats = flight.Seats;
          this.seats_week = flight['Seats/Week'];
          this.stops = flight.Stops;
          this.pointList = [this.origin.latlng, this.destination.latlng];
          L.MapPaths.addInitializedPath(this);
          return this.drawPath();
        },
        midPoint: function(points, ud) {
          var latDif, midPoint;
          midPoint = [];
          latDif = Math.abs(points[0].lat - points[1].lat);
          if (points[0].lat > points[1].lat) {
            if (ud) {
              midPoint[0] = points[1].lat + latDif / 4;
            } else {
              midPoint[0] = points[0].lat - latDif / 4;
            }
          } else {
            if (ud) {
              midPoint[0] = points[1].lat + latDif / 4;
            } else {
              midPoint[0] = points[1].lat - latDif / 4;
            }
          }
          midPoint[1] = (points[0].lng + points[1].lng) / 2;
          return midPoint;
        },
        calculateArch: function() {
          var curved, line;
          line = {
            'geometry': {
              'coordinates': [[this.origin.latlng.lat, this.origin.latlng.lng], this.midPoint([this.origin.latlng, this.destination.latlng], true), [this.destination.latlng.lat, this.destination.latlng.lng]]
            }
          };
          curved = turf.bezier(line, 10000, 1);
          return this.pointList = curved.geometry.coordinates;
        },
        refresh: function() {
          this.setPopup();
          this.hide();
          this.drawPath();
          return this.show();
        },
        setPopup: function() {
          var div, popup;
          popup = new L.popup();
          div = L.DomUtil.create("div", "");
          Blaze.renderWithData(Template.pathDetails, this, div);
          popup.setContent(div);
          return this.pathLine.bindPopup(popup);
        },
        setStyle: function(color, weight) {
          this.color = color;
          return this.weight = weight;
        },
        drawPath: function() {
          var archPos, i, len, mapPath, ref;
          this.visible = true;
          archPos = [];
          ref = L.MapPaths.mapPaths;
          for (i = 0, len = ref.length; i < len; i++) {
            mapPath = ref[i];
            if (mapPath !== this) {
              if ((mapPath.origin.equals(this.origin)) && (mapPath.destination.equals(this.destination))) {
                archPos[mapPath.archPosition] = true;
              }
            }
          }
          this.calculateArch(archPos);
          this.pathLine = new L.Polyline(this.pointList, {
            color: this.color,
            weight: this.weight,
            opacity: 0.8,
            smoothFactor: 1
          });
          return this.setPopup();
        }
      });
      L.mapPath = function(flight, map) {
        return new L.MapPath(flight, map);
      };
      L.MapPaths = {
        mapPaths: [],
        factors: [],
        getLayerGroup: function() {
          return L.layerGroup(this.mapPaths);
        },
        getFactorById: function(id) {
          var factor, i, len, ref;
          ref = this.factors;
          for (i = 0, len = ref.length; i < len; i++) {
            factor = ref[i];
            if (factor._id === id) {
              return factor;
            }
          }
          return false;
        },
        getMapPathByFactor: function(factor) {
          var i, len, ref, tempMapPath;
          ref = this.mapPaths;
          for (i = 0, len = ref.length; i < len; i++) {
            tempMapPath = ref[i];
            if (tempMapPath.origin.id === factor["Orig"]._id && tempMapPath.destination.id === factor["Dest"]._id) {
              return tempMapPath;
            }
          }
          return false;
        },
        addInitializedPath: function(mapPath) {
          return this.mapPaths.push(mapPath);
        },
        addFactor: function(id, factor, map) {
          var path;
          if (this.getFactorById(id) !== false) {
            return;
          }
          factor._id = id;
          path = this.getMapPathByFactor(factor);
          if (path !== false) {
            path.seats += factor["Seats"];
            path.flights++;
            path.refresh();
            this.factors.push(factor);
          } else if (path === false) {
            path = new L.MapPath(factor, map).addTo(map);
            path.seats = factor["Seats"];
            path.flights++;
            path.refresh();
            this.factors.push(factor);
          }
          return path;
        },
        removeFactor: function(id) {
          var d1, d2, factor, i, len, o1, o2, path, ref, removeDest, removeOrig, tempMapPath;
          factor = this.getFactorById(id);
          if (factor === false) {
            return false;
          }
          this.factors.splice(this.factors.indexOf(factor), 1);
          path = this.getMapPathByFactor(factor);
          path.seats -= factor["Seats"];
          path.flights--;
          path.hide();
          if (path.flights === 0) {
            removeDest = true;
            removeOrig = true;
            o1 = path.origin;
            d1 = path.destination;
            ref = this.mapPaths;
            for (i = 0, len = ref.length; i < len; i++) {
              tempMapPath = ref[i];
              o2 = tempMapPath.origin;
              d2 = tempMapPath.destination;
              if ((o2.id === o1.id || o1.id === d2.id) && tempMapPath !== path) {
                removeOrig = false;
              }
              if ((d2.id === d1.id || d1.id === o2.id) && tempMapPath !== path) {
                removeDest = false;
              }
            }
            if (removeDest) {
              path.destination.hide();
              L.MapNodes.mapNodes.splice(L.MapNodes.mapNodes.indexOf(path.destination), 1);
            }
            if (removeOrig) {
              path.origin.hide();
              L.MapNodes.mapNodes.splice(L.MapNodes.mapNodes.indexOf(path.origin), 1);
            }
            this.mapPaths.splice(this.mapPaths.indexOf(path), 1);
            return false;
          } else {
            path.show();
            return {
              "path": path,
              "factor": factor
            };
          }
        },
        updatePath: function(id, mapPath, map) {
          var i, len, ref, results, tempMapPath;
          ref = this.mapPaths;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            tempMapPath = ref[i];
            if (tempMapPath.id === id) {
              tempMapPath.hide();
              tempMapPath.update(mapPath);
              results.push(tempMapPath.show());
            } else {
              results.push(void 0);
            }
          }
          return results;
        },
        showPath: function(mapPath) {
          return mapPath.show();
        },
        hidePath: function(mapPath) {
          return mapPath.hide();
        },
        hideAllPaths: function() {
          var i, len, path, ref, results;
          ref = this.mapPaths;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            path = ref[i];
            results.push(path.hide());
          }
          return results;
        },
        showAllPaths: function() {
          var i, len, path, ref, results;
          ref = this.mapPaths;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            path = ref[i];
            results.push(path.show());
          }
          return results;
        },
        hideAllNodes: function() {
          var i, len, node, ref, results;
          ref = L.MapNodes.mapNodes;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            node = ref[i];
            results.push(node.hide());
          }
          return results;
        },
        showAllNodes: function() {
          return L.MapNodes.showAllNodes();
        },
        hideBetween: function(mapNodeA, mapNodeB) {
          var i, len, mapPath, ref, results;
          ref = this.mapPaths;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            mapPath = ref[i];
            if (mapPath.origin === mapNodeA && mapPath.destination === mapNodeB) {
              mapPath.hide();
            }
            if (mapPath.origin === mapNodeB && mapPath.destination === mapNodeA) {
              results.push(mapPath.hide());
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      };
      L.MapNode = L.Path.extend({
        visible: false,
        latlng: null,
        city: null,
        code: null,
        country: null,
        countryName: null,
        globalRegion: null,
        name: null,
        notes: null,
        state: null,
        stateName: null,
        wac: null,
        key: null,
        map: null,
        marker: null,
        onAdd: function(map) {
          if (this.marker !== null) {
            this.marker.addTo(map);
          }
        },
        onRemove: function(map) {
          map.removeLayer(this.marker);
        },
        setPopup: function() {
          var div, popup;
          popup = new L.popup();
          div = L.DomUtil.create("div", "");
          Blaze.renderWithData(Template.nodeDetails, this, div);
          popup.setContent(div);
          return this.marker.bindPopup(popup);
        },
        initialize: function(node, map) {
          var i, len, ref, results;
          this.map = map;
          this.id = node['_id'];
          this.city = node.City;
          this.code = node.Code;
          this.country = node.Country;
          this.countryName = node['Country Name'];
          this.globalRegion = node['Global Region'];
          this.name = node.Name;
          this.notes = node.Notes;
          this.state = node.State;
          this.stateName = node['State Name'];
          this.wac = node.WAC;
          this.key = node.key;
          this.latlng = new L.LatLng(node.loc.coordinates[1], node.loc.coordinates[0]);
          if (!L.MapNodes.contains(this)) {
            this.marker = L.marker(this.latlng);
            L.MapNodes.addInitializedNode(this);
            return this.setPopup();
          } else {
            ref = L.MapNodes.mapNodes;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              node = ref[i];
              if (node.id === this.id) {
                results.push(this.marker = node.marker);
              } else {
                results.push(void 0);
              }
            }
            return results;
          }
        },
        equals: function(otherNode) {
          return (otherNode.latlng.lat === this.latlng.lat) && (otherNode.latlng.lng === this.latlng.lng);
        },
        hide: function() {
          this.visible = false;
          return this.map.removeLayer(this.marker);
        },
        show: function() {
          this.visible = true;
          this.marker = L.marker(this.latlng);
          return this.setPopup();
        }
      });
      L.MapNodes = {
        mapNodes: [],
        getLayerGroup: function() {
          return L.layerGroup(this.mapNodes);
        },
        addInitializedNode: function(node) {
          return this.mapNodes.push(node);
        },
        addNode: function(mapNode) {
          var exists, i, len, ref, tempMapNode;
          exists = false;
          ref = this.mapNodes;
          for (i = 0, len = ref.length; i < len; i++) {
            tempMapNode = ref[i];
            if (tempMapNode.key === mapNode["_id"]) {
              exists = true;
            }
          }
          if (!exists) {
            return new L.MapNode(mapNode, this.map);
          }
        },
        removeNode: function(id) {
          var i, len, ref, tempMapNode;
          ref = this.mapNodes;
          for (i = 0, len = ref.length; i < len; i++) {
            tempMapNode = ref[i];
            if (tempMapNode.id === id) {
              tempMapNode.hide();
              this.mapNodes.splice(this.mapNodes.indexOf(tempMapNode), 1);
              return;
            }
          }
        },
        updateNode: function(mapNode) {
          var i, len, ref, results, tempMapNode;
          ref = this.mapNodes;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            tempMapNode = ref[i];
            if (tempMapNode.id === tempMapNode["_id"]) {
              tempMapNode.hide();
              tempMapNode.initialize(mapNode, this.map);
              results.push(tempMapNode.show());
            } else {
              results.push(void 0);
            }
          }
          return results;
        },
        contains: function(node) {
          var i, len, mapNode, mapNodesContains, ref;
          mapNodesContains = false;
          ref = this.mapNodes;
          for (i = 0, len = ref.length; i < len; i++) {
            mapNode = ref[i];
            if (mapNode.id === node.id) {
              mapNodesContains = true;
            }
          }
          return mapNodesContains;
        },
        mapNodeCount: function() {
          return this.mapNodes.length;
        },
        hideNode: function(node) {
          return node.hide();
        },
        showNode: function(node) {
          return node.show();
        },
        hideAllNodes: function() {
          var i, len, node, ref, results;
          ref = this.mapNodes;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            node = ref[i];
            results.push(node.hide());
          }
          return results;
        },
        showAllNodes: function() {
          var i, len, node, ref, results;
          ref = this.mapNodes;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            node = ref[i];
            results.push(node.show());
          }
          return results;
        }
      };
      L.mapNode = function(node, map) {
        return new L.MapNode(node, map);
      };
    } else {
      console.log('Leaflet Object [L] is missing.');
    }
  }

}).call(this);

//# sourceMappingURL=grits-net-mapper.js.map
